<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>TRBE — Team Mini App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700;800&display=swap" rel="stylesheet">
  <style>
  :root{
    --bg-1:#0b0a0d; --bg-2:#131017;
    --text:#EDEAF5; --muted:#B9B4C8;
    --stroke:rgba(255,255,255,.12);
    --radius:16px; --radius-lg:18px;
    --shadow:0 10px 30px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.03);
    --accent-1:#b142b4; --accent-2:#c27bff;
    --glass:rgba(255,255,255,.06);
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--text); font-family:"Manrope",system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
    -webkit-font-smoothing:antialiased;
    background-attachment: fixed;
    background-image:
      radial-gradient(1200px 800px at 20% -10%, rgba(177,66,180,.22), transparent 60%),
      radial-gradient(1100px 700px at 90% 0%,   rgba(194,123,255,.18), transparent 55%),
      radial-gradient(1400px 900px at 80% 120%, rgba(177,66,180,.16), transparent 60%),
      linear-gradient(180deg, var(--bg-1), var(--bg-2));
    background-blend-mode: screen, screen, screen, normal;
    padding:18px 16px max(28px, calc(env(safe-area-inset-bottom) + 90px));
  }

  .wrap{max-width:1100px; margin:0 auto;}

  /* Hero */
  .hero{display:grid; gap:8px; margin:6px 0 18px; text-align:center;}
  .pill{
    display:inline-block; font-size:12px; color:var(--muted);
    border:1px solid var(--stroke); border-radius:999px; padding:6px 10px;
    backdrop-filter:blur(10px);
    background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
  }
  h1{font-size:clamp(28px,4.8vw,44px); line-height:1.05; margin:2px 0 0; font-weight:800; letter-spacing:-.5px}
  .gradient{background:linear-gradient(90deg, var(--accent-1), var(--accent-2)); -webkit-background-clip:text; background-clip:text; -webkit-text-fill-color:transparent}
  .motd{color:var(--muted); font-size:14px; margin-top:4px}

  /* Landing */
  .three-grid{display:grid; gap:14px; grid-template-columns:1fr; margin:16px 0 8px}
  @media (min-width:860px){ .three-grid{grid-template-columns:repeat(3,1fr)} }
  .tile{
    display:flex; gap:10px; align-items:center; justify-content:center;
    background:var(--glass); border:1px solid var(--stroke); border-radius:24px;
    box-shadow:var(--shadow); padding:26px; cursor:pointer; text-align:center;
    transition: transform .05s ease, filter .15s ease;
  }
  .tile:hover{ filter:brightness(1.06) } .tile:active{ transform:translateY(1px) }
  .tile h2{ margin:0; font-size:18px; font-weight:800 }

  /* Panels & cards */
  .panel{ display:none; margin-top:16px; }
  .card-header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    margin-bottom:12px;
  }
  .card-header h3{
    margin:0;
  }
  .back{
    appearance:none; border:0; color:#fff; font-weight:800;
    padding:10px 16px; border-radius:12px; cursor:pointer;
    background:linear-gradient(90deg, var(--accent-1), var(--accent-2));
    box-shadow:0 8px 20px rgba(177,66,180,.28), inset 0 1px 0 rgba(255,255,255,.12);
    white-space:nowrap;
    font-size:13px;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    line-height:1;
    flex-shrink:0;
  }
  .card{
    background:var(--glass); border:1px solid var(--stroke); border-radius:var(--radius-lg);
    box-shadow:var(--shadow); padding:14px; margin-bottom:14px; backdrop-filter: blur(8px);
  }
  .card h3{font-size:16px; margin:0 0 10px; font-weight:800}
  .hint{color:var(--muted); font-size:12px}

  .toolbar{display:grid; gap:10px; grid-template-columns:1fr; margin-bottom:10px}
  @media (min-width:700px){ .toolbar{grid-template-columns: 1fr 260px} }
    
    .dashboard-filters{
    display:flex;
    flex-wrap:wrap;
    column-gap:12px;
    row-gap:10px;
    align-items:stretch;
    margin:4px 0 12px;
  }
  .dashboard-filter-item{
    flex:1 1 clamp(180px, 33%, 280px);
    min-width:160px;
    display:flex;
  }
  .dashboard-filter-item > *{
    width:100%;
    min-height:46px;
  }
  @media (max-width:520px){
    .dashboard-filter-item{
      flex:1 1 calc(50% - 12px);
      min-width:150px;
    }
  }
    @media (max-width:400px){
    .dashboard-filter-item{
      flex:1 1 100%;
      min-width:0;
    }
  }


  input, textarea, select{
    width:100%; color:var(--text);
    background:rgba(255,255,255,.04); border:1px solid var(--stroke);
    border-radius:12px; padding:12px 14px; outline:none;
  }
  textarea{min-height:110px; resize:vertical}

  .btn{
    appearance:none; border:0; color:#fff; font-weight:800;
    padding:14px 16px; border-radius:16px; cursor:pointer;
    background:linear-gradient(90deg, var(--accent-1), var(--accent-2));
    box-shadow:0 8px 20px rgba(177,66,180,.28), inset 0 1px 0 rgba(255,255,255,.12);
    transition:transform .05s ease, filter .15s ease; white-space:nowrap;
  }
  .btn:hover{filter:brightness(1.06)} .btn:active{transform:translateY(1px)}
  .btn.secondary{
    background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
    color:var(--text);
  }
  .btn.mini{padding:9px 12px; font-size:13px; border-radius:12px}
  .btn:disabled{opacity:.6; filter:grayscale(40%)}

    /* Modal */
  .modal-backdrop{
    position:fixed; inset:0; z-index:4500;
    display:none; align-items:center; justify-content:center;
    background:rgba(9,7,12,.82);
  }
  .modal-backdrop[aria-hidden="false"]{display:flex}
  .modal-card{
    width:min(420px, 94vw);
    background:#201a2a;
    border:1px solid rgba(255,255,255,.08);
    border-radius:20px;
    box-shadow:0 20px 48px rgba(0,0,0,.55);
    padding:20px;
    display:flex; flex-direction:column; gap:14px;
  }
  .modal-card h3{margin:0; font-size:18px; font-weight:800}
  .modal-field{display:flex; flex-direction:column; gap:6px}
  .modal-label{font-size:13px; font-weight:600; color:var(--muted)}
  .modal-actions{display:flex; justify-content:flex-end; gap:10px}
  .modal-actions .btn{min-width:120px}
  .modal-actions .btn.secondary{min-width:auto}
  .modal-status{font-size:13px; min-height:18px}
  .modal-status.loading{color:var(--muted)}
  .modal-status.error{color:#ff8a9f}
  .modal-status.success{color:#96f6c7}
    
    /* Tasks */
  .task-list{list-style:none; padding:0; margin:8px 0 0; display:flex; flex-direction:column; gap:8px}
  .task-item{display:flex; align-items:flex-start; gap:10px; padding:10px 12px; border:1px solid var(--stroke); border-radius:12px; background:rgba(255,255,255,.04)}
  .task-item.completed{opacity:.7}
  .task-item label{display:flex; gap:10px; width:100%; cursor:pointer}
  .task-item span{flex:1}
  .task-check{margin-top:2px; width:18px; height:18px; accent-color:var(--accent-2)}
  .task-meta{font-size:12px; color:var(--muted); margin-top:4px}
  .task-empty{padding:12px; border:1px dashed rgba(255,255,255,.12); border-radius:12px; color:var(--muted); text-align:center; font-size:13px}
  .assign-task-toolbar{margin-bottom:8px}
  .assign-task-side{display:grid; gap:8px}
  .assign-task-side .btn{width:100%}
  @media (min-width:700px){ .assign-task-toolbar{grid-template-columns:1fr 220px} }
    
  /* Chats list (dashboard) */
  .list{list-style:none; padding:0; margin:8px 0 0; border:1px solid var(--stroke); border-radius:12px; overflow:hidden}
  .row{
    display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center;
    padding:12px 14px; border-bottom:1px solid rgba(255,255,255,.08); background:rgba(255,255,255,.03);
    cursor:pointer;
  }
  .row:hover{background:rgba(255,255,255,.07)}
  .row:last-child{border-bottom:0}
  .title{font-weight:700}
  .sub{font-size:12px; color:var(--muted)}
  .status-pill{
    padding:6px 10px; border-radius:999px;
    background:linear-gradient(90deg, var(--accent-1), var(--accent-2));
    font-size:11px; font-weight:800; letter-spacing:.2px; justify-self:end;
  }
    .status-stack{display:flex; flex-direction:column; align-items:flex-end; gap:6px; text-align:right;}
  .grant-pill{
    font-size:13px; font-weight:600; padding:6px 10px; border-radius:999px;
    background:linear-gradient(90deg,var(--accent-1),var(--accent-2));
    color:white; display:inline-block;
  }

  .mini-tool{
    margin-top:10px;
    padding:12px;
    border:1px solid var(--stroke);
    border-radius:12px;
    background:rgba(255,255,255,0.02);
    display:flex;
    flex-direction:column;
    gap:10px;
  }
  .mini-tool:first-child{margin-top:0;}
  .mini-tool label{font-size:13px; font-weight:700; color:var(--muted);}
  .mini-actions{display:flex; justify-content:flex-end; gap:10px;}
  .mini-actions .btn{min-width:110px;}

  pre.out{background:rgba(0,0,0,.35); border:1px solid var(--stroke); border-radius:12px; padding:12px; margin:10px 0 0; white-space:pre-wrap; max-height:280px; overflow:auto}
    .ai-response-box{
    background:rgba(255,255,255,.04);
    border:1px solid var(--stroke);
    border-radius:12px;
    padding:12px;
    font:inherit;
    color:var(--text);
    white-space:pre-wrap;
    word-break:break-word;
    max-height:280px;
    overflow:auto;
  }
  .section-title{font-weight:800; margin:10px 0 8px}

  /* Timelines */
  .timeline{border:1px dashed rgba(255,255,255,.25); border-radius:12px; padding:12px; color:var(--muted)}
  .timeline .bar{height:12px; border-radius:999px; background:linear-gradient(90deg, var(--accent-1), var(--accent-2)); margin:8px 0 4px}

  /* Accordion */
  .acc{border:1px solid var(--stroke); border-radius:12px; overflow:hidden; margin-top:8px}
  .acc-item + .acc-item{border-top:1px solid var(--stroke)}
  .acc-head{display:flex; justify-content:space-between; align-items:center; padding:12px 14px; cursor:pointer; background:rgba(255,255,255,.04)}
  .acc-head h4{margin:0; font-size:16px}
  .acc-body{display:none; padding:12px 14px; background:rgba(255,255,255,.03)}
  .chev{transition:transform .15s ease}
  .acc-item.open .acc-body{display:block}
  .acc-item.open .chev{transform:rotate(180deg)}

  /* -------- Full-screen chooser (Select chats) -------- */
  .chooser-full{
    position:fixed; inset:0; z-index:3000;
    display:none; flex-direction:column; align-items:center;
    background:linear-gradient(180deg, #15111c, #0f0d14);
  }
  .chooser-full[aria-hidden="false"]{display:flex}

  .chooser-shell{
    width:min(900px, 98vw);
    height:min(96vh, 100%);
    margin:clamp(8px, 2vh, 18px) 0;
    background:#1b1623; border:1px solid var(--stroke); border-radius:20px;
    box-shadow:0 20px 40px rgba(0,0,0,.55), inset 0 1px 0 rgba(255,255,255,.05);
    display:flex; flex-direction:column; overflow:hidden;
  }

  .chooser-top{
    position:sticky; top:0; z-index:1;
    display:grid; gap:10px; grid-template-columns:1fr 220px auto auto;
    padding:12px; background:#1b1623; border-bottom:1px solid var(--stroke);
  }
  .chooser-title{align-self:center; font-weight:800}
  .chooser-list{
    list-style:none; margin:0; padding:0;
    overflow:auto; flex:1; -webkit-overflow-scrolling:touch;
  }
  .chooser-row{
    display:grid; grid-template-columns:auto 1fr auto; gap:10px; align-items:center;
    padding:12px 14px; border-bottom:1px solid rgba(255,255,255,.08); background:rgba(255,255,255,.02);
  }
  .chooser-row:hover{background:rgba(255,255,255,.06)}
  .chooser-row:last-child{border-bottom:0}
  .send-tick{ width:18px; height:18px; accent-color:#c27bff }

  /* Final confirm popup (unchanged) */
  .chooser-backdrop{
      position: fixed; inset: 0;
      display: none; align-items: center; justify-content: center;
      background: rgba(10,8,14,.85);  /* opaque-ish dark backdrop */
      z-index: 4000;
  }
  .chooser-card{
      width: min(720px, 96vw);
      background: #201a2a;                     /* solid background */
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 20px;
      box-shadow: 0 24px 60px rgba(0,0,0,.6);
      padding: 14px;
      backdrop-filter: none;                    /* kill the blur */
  }

  /* Chips for selected chats */
  #sendChosenChips{ display:flex; flex-wrap:wrap; gap:8px; }
  .chip{
    display:inline-flex; align-items:center; gap:8px;
    padding:6px 10px; border-radius:999px;
    background:rgba(255,255,255,.08); border:1px solid var(--stroke);
    font-size:12px;
  }
  .chip .x{
    display:inline-block; width:16px; height:16px; line-height:16px; text-align:center;
    border-radius:50%; background:rgba(255,255,255,.18); cursor:pointer; font-weight:800;
  }
  </style>
</head>
<body>
  <div class="wrap">

    <!-- Header -->
    <div class="hero">
      <span class="pill">TRBE Team Mini App</span>
      <h1>Get info without browsing chats. <span class="gradient">TRBE</span></h1>
      <div id="who" class="motd"></div>
      <div id="motd" class="motd"></div>
    </div>


    <!-- Landing: three boxes -->
    <div id="landing" class="three-grid">
      <div class="tile" data-open="panel-chats"><h2>Chats</h2></div>
      <div class="tile" data-open="panel-team"><h2>Team</h2></div>
      <div class="tile" data-open="panel-ai"><h2>AI Assistant</h2></div>
    </div>

    <!-- PANEL: CHATS -->
    <div id="panel-chats" class="panel">

      <!-- Dashboard -->
      <section class="card">
        <div class="card-header">
          <h3>Dashboard</h3>
          <button class="back" data-back>Back to Main</button>
        </div>
        <div class="dashboard-filters">
          <div class="dashboard-filter-item">
            <input id="searchChats" placeholder="Search by name…" />
          </div>
          <div class="dashboard-filter-item">
            <select id="statusFilter" class="filter-select" title="Filter by status">
              <option value="">All statuses</option>
              <option>Talking</option>
              <option>Awaiting data</option>
              <option>Awaiting SoW</option>
              <option>SoW signed</option>
              <option>Awaiting payment</option>
              <option>Paid</option>
              <option>Data collection</option>
              <option>Campaign launched</option>
              <option>Report awaiting</option>
              <option>Finished</option>
            </select>
          </div>
          <div class="dashboard-filter-item">
            <select id="grantFilter" class="filter-select" title="Filter by grant program">
              <option value="">All grants</option>
              <option>MultiversX</option>
              <option>TON</option>
              <option>Fastex</option>
              <option>BNB Chain</option>
            </select>
          </div>
        </div>
        <ul id="chats" class="list"></ul>
        <div class="hint">Tip: click a chat to auto-fill all tools below.</div>
      </section>

      <!-- Timelines -->
      <section class="card">
        <h3>Product launches (all projects)</h3>
        <div id="timelineProduct" class="timeline"><div class="bar"></div><div class="hint">Timeline placeholder — product launch milestones will appear here.</div></div>
      </section>
      <section class="card">
        <h3>Campaign launches (all projects)</h3>
        <div id="timelineCampaign" class="timeline"><div class="bar"></div><div class="hint">Timeline placeholder — campaign launch windows will appear here.</div></div>
      </section>

      <!-- Tools -->
      <section class="card">
        <h3>Tools</h3>

        <div class="acc" id="toolsAcc">
        <!-- 1) Summary -->
        <div class="acc-item">
          <div class="acc-head"><h4>1) Summarize</h4><span class="chev">▾</span></div>
          <div class="acc-body">
            <div class="toolbar" style="grid-template-columns:1fr 200px">
              <input id="chatIdSum" placeholder="Enter chat_id for summary" />
              <button class="btn" id="doSummary">Summarize</button>
            </div>
            <div id="summaryOut" style="
              background: rgba(255, 255, 255, 0.04);
              border: 1px solid var(--stroke);
              border-radius: 12px;
              padding: 12px 14px;
              color: var(--text);
              font-size: 13px;
              font-weight: normal;
              margin-top: 8px;
            ">—</div>
          </div>
        </div>

          <!-- 2) Status -->
          <div class="acc-item">
            <div class="acc-head"><h4>2) Status</h4><span class="chev">▾</span></div>
            <div class="acc-body">
              <h4 style="margin-top:8px; font-size:16px">• Status</h4>
              <div class="toolbar" style="grid-template-columns:1fr 200px">
                <input id="chatIdStatus" placeholder="Enter chat_id for status" />
                <button class="btn" id="getStatus">Get status</button>
                </div>
              <div class="toolbar" style="grid-template-columns:minmax(160px,1fr) repeat(3, auto)">
                <select id="statusSel" disabled>
                  <option>Talking</option><option>Awaiting data</option><option>Awaiting SoW</option>
                  <option>SoW signed</option><option>Awaiting payment</option><option>Paid</option>
                  <option>Data collection</option><option>Campaign launched</option><option>Report awaiting</option><option>Finished</option>
                </select>
                <button class="btn secondary" id="editStatusBtn">Edit</button>
                <button class="btn" id="saveStatus" disabled>Save</button>
                <button class="btn secondary" id="cancelStatus" disabled style="visibility:hidden">Cancel</button>
              </div>
              <div id="statusOut" style="
                background: rgba(255, 255, 255, 0.04);
                border: 1px solid var(--stroke);
                border-radius: 12px;
                padding: 12px 14px;
                color: var(--text);
                font-size: 13px;
                font-weight: normal;
                margin-top: 8px;
              ">—</div>

              <h4 style="margin-top:16px; font-size:16px">• Grant Projects</h4>
              <div class="toolbar" style="grid-template-columns:1fr 200px; margin-bottom:8px">
                <input id="chatIdGrant" placeholder="Enter chat_id for grant assignment" />
                <select id="grantSelect" disabled>
                  <option value="">— None —</option>
                </select>
                </div>
              <div class="toolbar" style="grid-template-columns:repeat(2, minmax(0, 1fr)); margin:0 0 8px">
                <button class="btn secondary" id="editGrantBtn" style="width:100%">Edit</button>
                <button class="btn" id="saveGrant" disabled style="width:100%">Save</button>
              </div>
              <div class="toolbar" id="grantCancelRow" style="grid-template-columns:1fr; justify-items:end; margin:0 0 8px; display:none">
                <button class="btn secondary" id="cancelGrant" disabled>Cancel</button>
              </div>
              <div id="grantOut" style="
                background: rgba(255, 255, 255, 0.04);
                border: 1px solid var(--stroke);
                border-radius: 12px;
                padding: 12px 14px;
                color: var(--text);
                font-size: 13px;
                font-weight: normal;
                margin-top: 8px;
              ">— None —</div>
            </div>
          </div>

          <!-- 3) Company blurb -->
          <div class="acc-item">
            <div class="acc-head"><h4>3) Company blurb</h4><span class="chev">▾</span></div>
            <div class="acc-body">
              <div class="toolbar" style="grid-template-columns:1fr 200px">
                <input id="chatIdCompany" placeholder="Enter chat_id for blurb" />
                <button class="btn" id="getBlurb">Get blurb</button>
              </div>
              <div id="blurbOut" style="
                background: rgba(255, 255, 255, 0.04);
                border: 1px solid var(--stroke);
                border-radius: 12px;
                padding: 12px 14px;
                color: var(--text);
                font-size: 13px;
                font-weight: normal;
                white-space: pre-wrap;
                word-break: break-word;
                margin-top: 8px;
              ">—</div>
            </div>
          </div>

          <!-- 4) Approx dates per chat -->
          <div class="acc-item">
            <div class="acc-head"><h4>4) Approximate dates (per chat)</h4><span class="chev">▾</span></div>
            <div class="acc-body">
              <h4 style="margin-top:8px; font-size:16px">• Product Launch</h4>
              <div class="toolbar" style="grid-template-columns:1fr 200px">
                <input id="chatIdDatesProd" placeholder="Enter chat_id for product date" />
                <button class="btn" id="getDatesProd">Get product date</button>
              </div>
              <div id="datesOutProd" style="
                background: rgba(255, 255, 255, 0.04);
                border: 1px solid var(--stroke);
                border-radius: 12px;
                padding: 12px 14px;
                color: var(--text);
                font-size: 13px;
                font-weight: normal;
                margin-top: 8px;
              ">Unknown</div>
          
              <h4 style="margin-top:16px; font-size:16px">• Campaign Launch</h4>
              <div class="toolbar" style="grid-template-columns:1fr 200px">
                <input id="chatIdDatesCamp" placeholder="Enter chat_id for campaign date" />
                <button class="btn" id="getDatesCamp">Get campaign date</button>
              </div>
              <div id="datesOutCamp" style="
                background: rgba(255, 255, 255, 0.04);
                border: 1px solid var(--stroke);
                border-radius: 12px;
                padding: 12px 14px;
                color: var(--text);
                font-size: 13px;
                font-weight: normal;
                margin-top: 8px;
              ">Unknown</div>
            </div>
          </div>

          <!-- 5) Next steps -->
          <div class="acc-item">
            <div class="acc-head"><h4>5) Next steps (AI)</h4><span class="chev">▾</span></div>
            <div class="acc-body">
              <div class="toolbar" style="grid-template-columns:1fr 200px">
                <input id="chatIdNext" placeholder="Enter chat_id for next steps" />
                <button class="btn" id="getNext">Suggest</button>
              </div>
              <div id="nextOut" style="
                background: rgba(255, 255, 255, 0.04);
                border: 1px solid var(--stroke);
                border-radius: 12px;
                padding: 12px 14px;
                color: var(--text);
                font-size: 13px;
                font-weight: normal;
                white-space: pre-wrap;
                word-break: break-word;
                margin-top: 8px;
              ">—</div>
            </div>
          </div>

        <!-- 6) Send a message -->
        <div class="acc-item">
          <div class="acc-head"><h4>6) Send a message</h4><span class="chev">▾</span></div>
          <div class="acc-body">
            <div class="toolbar" style="grid-template-columns:1fr 200px">
              <input id="sendChosenSummary" placeholder="No chats selected" disabled />
              <button class="btn" id="openSendChooser">Select chats</button>
            </div>

            <!-- Compose ABOVE chips -->
            <div id="sendCompose" style="display:none; margin-top:8px">
              <div class="toolbar" style="grid-template-columns:1fr 160px; margin:0 0 8px 0">
                <textarea id="sendText" placeholder="Type a message to send to all selected chats…"></textarea>
                <button class="btn" id="sendMessageBtn">Send message</button>
              </div>
              <div class="hint">Selected chats:</div>
              <div id="sendChosenChips" style="margin:6px 0 8px"></div>
            </div>

            <!-- Full-screen chooser -->
            <div id="sendChooserFull" class="chooser-full" aria-hidden="true" role="dialog" aria-modal="true">
              <div class="chooser-shell">
                <div class="chooser-top">
                  <div class="chooser-title">Select chats</div>
                  <input id="sendSearch" placeholder="Search by title, @username, or id…" />
                  <select id="sendStatusFilter">
                    <option value="">All statuses</option>
                    <option>Talking</option><option>Awaiting data</option><option>Awaiting SoW</option>
                    <option>SoW signed</option><option>Awaiting payment</option><option>Paid</option>
                    <option>Data collection</option><option>Campaign launched</option><option>Report awaiting</option><option>Finished</option>
                  </select>
                  <button class="btn secondary" id="cancelSendSelection">Cancel</button>
                  <button class="btn" id="confirmSendSelection" disabled>Confirm</button>
                </div>
                <ul id="sendChatsList" class="chooser-list"></ul>
                <div class="hint" style="padding:10px 12px; border-top:1px solid var(--stroke)">Tip: tick multiple chats, then press “Confirm”.</div>
              </div>
            </div>

            <!-- Final confirm popup -->
            <div id="sendConfirm" class="chooser-backdrop" aria-hidden="true">
              <div class="chooser-card">
                <h3 style="margin:0 0 8px 0">Confirm send</h3>
                <div class="hint" style="margin-bottom:8px">Are you sure you want to send this message to these chats?</div>
                <div class="section-title" style="margin:0 0 6px 0">Message preview</div>
                <pre id="sendConfirmMsg" class="out" style="max-height:140px"></pre>
                <div class="section-title" style="margin:8px 0 6px 0">Chats selected</div>
                <ul id="sendConfirmList" class="list"></ul>
                <div style="display:grid; gap:10px; grid-template-columns: 1fr 1fr; margin-top:10px">
                  <button class="btn secondary" id="sendConfirmCancel">Cancel</button>
                  <button class="btn" id="sendConfirmGo">Confirm send</button>
                </div>
              </div>
            </div>

          </div>
        </div>
      </section>
    </div>

    <!-- PANEL: TEAM -->
    <div id="panel-team" class="panel">
      
      <section class="card" id="teamTasksCard">
        <div class="card-header">
          <h3>Team</h3>
          <button class="back" data-back>Back to Main</button>
        </div>
        <div class="toolbar" style="grid-template-columns: 1fr 200px;">
          <input id="taskSearch" placeholder="Search tasks…" />
          <select id="teamSelect">
            <option value="">Choose a teammate…</option>
            <option value="@Shefer712">Arina — @Shefer712</option>
            <option value="@Web3Reachout">Kate — @Web3Reachout</option>
            <option value="@travalss">Val — @travalss</option>
            <option value="@phoebemangoba">Phoebe — @phoebemangoba</option>
          </select>
        </div>
                <div id="taskMessage" class="hint">Choose a teammate to see their tasks.</div>
        <ul id="taskList" class="task-list" aria-live="polite"></ul>
      </section>

      <section class="card" id="assignTaskCard">
        <h3>Assign a task</h3>
        <div class="toolbar assign-task-toolbar">
          <textarea id="newTaskText" placeholder="Describe the task…" rows="3" style="font-size: 14px;"></textarea>
          <div class="assign-task-side">
            <select id="newTaskAssignee">
              <option value="">Assign to…</option>
              <option value="@Shefer712">Arina — @Shefer712</option>
              <option value="@Web3Reachout">Kate — @Web3Reachout</option>
              <option value="@travalss">Val — @travalss</option>
              <option value="@phoebemangoba">Phoebe — @phoebemangoba</option>
            </select>
            <button class="btn" id="addTaskBtn">Assign task</button>
          </div>
        </div>
        <div id="newTaskHint" class="hint">Tasks appear for the teammate you assign them to.</div>
      </section>

      <section class="card" id="completedTasksCard">
        <h3>See past tasks</h3>
        <div id="completedTasksMessage" class="hint">Choose a teammate to see their tasks.</div>
        <ul id="completedTaskList" class="task-list" aria-live="polite"></ul>
      </section>

      <button class="btn" id="createReportBtn" style="width:100%; margin-top:6px">Create a report</button>
    </div>

    <!-- PANEL: AI -->
    <div id="panel-ai" class="panel">
      <section class="card">
        <div class="card-header">
          <h3>AI Assistant</h3>
          <button class="back" data-back>Back to Main</button>
        </div>
        <!-- Select chat -->
        <div class="toolbar" style="grid-template-columns: 1fr;">
          <select id="aiChatSelect">
            <option value="">Select a chat…</option>
          </select>
        </div>
    
        <!-- Prompt input -->
        <div class="toolbar" style="grid-template-columns: 1fr auto; margin-top:10px">
          <textarea id="aiPromptInput" placeholder="Ask your question based on the chat…" rows="3" style="font-size: 14px;"></textarea>
          <button class="btn" id="askAiBtn">Ask AI</button>
        </div>
    
        <!-- AI output -->
        <pre id="aiResult" class="ai-response-box" style="margin-top:10px; font-size: 14px; font-weight: normal;">Response will appear here…</pre>
      </section>
    </div>
  </div>

  <div id="reportModal" class="modal-backdrop" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="reportModalTitle">
      <h3 id="reportModalTitle">Create report</h3>
      <div class="modal-field">
        <label class="modal-label" for="reportStartDate">Start date</label>
        <input type="date" id="reportStartDate" />
      </div>
      <div class="modal-field">
        <label class="modal-label" for="reportEndDate">End date</label>
        <input type="date" id="reportEndDate" />
      </div>
      <div id="reportStatus" class="modal-status" aria-live="polite"></div>
      <div class="modal-actions">
        <button type="button" class="btn secondary" id="reportCancelBtn">Cancel</button>
        <button type="button" class="btn" id="reportConfirmBtn">Confirm</button>
      </div>
    </div>
  </div>
  
  <script>
    /* Telegram */
    const Telegram = window.Telegram;
    const tg = Telegram?.WebApp; tg?.ready?.(); tg?.expand?.();
    const user = tg?.initDataUnsafe?.user;
    const telegramAuth = (() => {
      if (!tg) {
        console.warn('Telegram WebApp SDK is unavailable; API auth headers cannot be populated.');
      } else if (!tg.initDataUnsafe) {
        console.warn('Telegram initDataUnsafe is unavailable; API auth headers may be missing.');
      }

      const initData = tg?.initData || '';
      const userId = user?.id != null ? user.id : null;
      const rawUsername = typeof user?.username === 'string' ? user.username : null;
      const username = rawUsername ? rawUsername.toLowerCase() : null;

      return {
        id: userId,
        username,
        initData,
        headers(){
          const headers = { 'x-telegram-init-data': initData || '' };
          if (userId != null) headers['x-telegram-id'] = String(userId);
          if (username) headers['x-telegram-username'] = username;
          return headers;
        }
      };
    })();
    document.getElementById('who').textContent =
      user ? `Hello, ${user.first_name} (@${user.username || 'no username'}) — id: ${user.id}` : 'Open this from Telegram to see user info.';
    const day = new Date().getDay();
    const motdMap = {1:'Monday — set the tone: plan the week and identify one “level-up” step.',2:'Tuesday — momentum day! Kill the smallest tasks and split big ones.',
      3:'Wednesday — breathe, you’re half-way through. Review blockers.',4:'Thursday — keep steady progress, stay productive without burning out.',
      5:'Friday — final push, then enjoy the weekend. Tie loose ends.',0:'Sunday — light planning beats heavy grinding. Prep your week.',6:'Saturday — rest & reflect. Tiny wins only.'};
    document.getElementById('motd').textContent = motdMap[day] || '';
    tg?.MainButton?.setText?.('Close'); tg?.MainButton?.onClick?.(()=>tg.close()); tg?.MainButton?.show?.();

    /* Router */
    const landing = document.getElementById('landing');
    const panels = {'panel-chats': document.getElementById('panel-chats'),'panel-team':document.getElementById('panel-team'),'panel-ai':document.getElementById('panel-ai')};
    document.querySelectorAll('.tile').forEach(t=>{
      t.addEventListener('click', ()=>{
        const id = t.getAttribute('data-open');
        landing.style.display='none'; Object.values(panels).forEach(p=>p.style.display='none');
        panels[id].style.display='block';
        if (id === 'panel-chats') {
          loadChats();
          loadTimelines();
          } else if (id === 'panel-team') {
          hydrateTasksFromServer();
        } else if (id === 'panel-ai') {
          loadCachedChatsForAi();
        }
      });
    });
    document.querySelectorAll('[data-back]').forEach(b=>{
      b.addEventListener('click', ()=>{
        Object.values(panels).forEach(p=>p.style.display='none'); landing.style.display='grid';
      });
    });

    /* Report modal */
    const reportModal      = document.getElementById('reportModal');
    const openReportBtn    = document.getElementById('createReportBtn');
    const reportStartInput = document.getElementById('reportStartDate');
    const reportEndInput   = document.getElementById('reportEndDate');
    const reportStatus     = document.getElementById('reportStatus');
    const reportCancelBtn  = document.getElementById('reportCancelBtn');
    const reportConfirmBtn = document.getElementById('reportConfirmBtn');

    function setReportStatus(message = '', state = ''){
      reportStatus.textContent = message;
      reportStatus.className = 'modal-status';
      if (state) reportStatus.classList.add(state);
    }

    function setReportLoading(isLoading){
      reportConfirmBtn.disabled = isLoading;
      reportCancelBtn.disabled = isLoading;
      reportStartInput.disabled = isLoading;
      reportEndInput.disabled = isLoading;
      reportConfirmBtn.textContent = isLoading ? 'Processing...' : 'Confirm';
    }

    function openReportModal(){
      setReportStatus('', '');
      setReportLoading(false);
      reportModal.setAttribute('aria-hidden','false');
      setTimeout(()=>reportStartInput?.focus(), 0);
    }

    function closeReportModal(){
      reportModal.setAttribute('aria-hidden','true');
      setReportLoading(false);
      setReportStatus('', '');
    }

    async function submitReport(){
      const startDate = reportStartInput.value;
      const endDate = reportEndInput.value;

      if (!startDate || !endDate){
        setReportStatus('Please select both a start and end date.', 'error');
        return;
      }
      if (new Date(startDate) > new Date(endDate)){
        setReportStatus('The end date must be the same as or after the start date.', 'error');
        return;
      }

      let isoStart;
      let isoEnd;

      try {
        isoStart = new Date(startDate).toISOString().split('T')[0];
        isoEnd = new Date(endDate).toISOString().split('T')[0];
      } catch (err) {
        setReportStatus('Please select valid dates.', 'error');
        return;
      }

      setReportLoading(true);
      setReportStatus('Processing...', 'loading');

      try{
        const res = await fetch('/api/generate-report', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...H.headers()
          },
          body: JSON.stringify({ startDate: isoStart, endDate: isoEnd })
        });

        const raw = await res.text();
        let data;
        try{
          data = raw ? JSON.parse(raw) : null;
        }catch(e){
          data = null;
        }

        if (!res.ok){
          const message = data?.message || data?.error || raw || 'Failed to generate report.';
          throw new Error(message);
        }

        setReportStatus('✅ Report sent to your email', 'success');
      }catch(err){
        console.error(err);
        setReportStatus('❌ Failed to generate report. Please try again.', 'error');
      }finally{
        setReportLoading(false);
      }
    }

    openReportBtn?.addEventListener('click', openReportModal);
    reportCancelBtn?.addEventListener('click', closeReportModal);
    reportConfirmBtn?.addEventListener('click', submitReport);
    reportModal?.addEventListener('click', e=>{ if (e.target === reportModal && !(reportConfirmBtn?.disabled)) closeReportModal(); });
    document.addEventListener('keydown', e=>{
      if (e.key === 'Escape' && reportModal?.getAttribute('aria-hidden') === 'false' && !(reportConfirmBtn?.disabled)){
        closeReportModal();
      }
    });
    
    /* Accordion */
    document.querySelectorAll('.acc-item .acc-head').forEach(h=>{
      h.addEventListener('click', ()=> h.parentElement.classList.toggle('open'));
    });

    /* Helpers */
    function debounce(fn, delay = 250){
      let timer = null;
      return (...args)=>{
        if (timer) clearTimeout(timer);
        timer = setTimeout(()=>fn.apply(null, args), delay);
      };
    }

    let activeChatId = null;
    function setActiveChat(id){ activeChatId = id ? String(id) : null; }
    function getActiveChat(){
      if (!activeChatId) return null;
      return (chatsCache || []).find(c => String(c.id) === String(activeChatId)) || null;
    }

    const H = {
      headers(){ return telegramAuth.headers(); },
      pickChat(id){
        ['chatIdSum','chatIdStatus','chatIdGrant','chatIdCompany','chatIdDatesProd','chatIdDatesCamp','chatIdNext'].forEach(k=>{
          const el=document.getElementById(k);
          if(el) el.value=id;
        });
        const aiSel = document.getElementById('aiChatSelect');
        if (aiSel) {
          const target = String(id);
          const hasOption = Array.from(aiSel.options || []).some(opt => opt.value === target);
          if (hasOption) {
            if (aiSel.value !== target) resetAiUi();
            aiSel.value = target;
          }
        }
        handleChatSelection(id);
        setActiveChat(id);
        syncStatusToolFromActiveChat();
      },
      fmtStatus(s){ return s || '—'; }
    };

    const chatMessagesListEl = document.getElementById('chatMessagesList');
    const chatMessagesStatusEl = document.getElementById('chatMessagesStatus');
    const MESSAGE_CACHE_KEY = 'trbe.cachedMessages';
    const MESSAGE_SYNC_KEY = 'trbe.lastSyncedAt';
    const LAST_CHAT_CACHE_KEY = 'trbe.lastChatId';
    const MAX_CACHED_MESSAGES = 500;

    const messageCacheState = {
      cache: new Map(),
      lastSynced: new Map(),
      lastChatId: null,
      syncing: new Set(),
    };

    loadStoredMessagesFromLocalStorage();
    restoreCachedMessagesOnInit();

    function storageAvailable(){
      try {
        return typeof window !== 'undefined' && typeof window.localStorage !== 'undefined';
      } catch (_) {
        return false;
      }
    }

    function safeJsonParse(value){
      if (!value) return null;
      try {
        return JSON.parse(value);
      } catch (_) {
        return null;
      }
    }

    function loadStoredMessagesFromLocalStorage(){
      if (!storageAvailable()) return;
      try {
        const rawMessages = safeJsonParse(localStorage.getItem(MESSAGE_CACHE_KEY));
        if (rawMessages && typeof rawMessages === 'object'){
          for (const [chatId, list] of Object.entries(rawMessages)){
            if (!Array.isArray(list)) continue;
            const normalized = list
              .slice(-MAX_CACHED_MESSAGES)
              .map(normalizeMessage)
              .filter(Boolean);
            if (normalized.length){
              normalized.sort((a,b)=> new Date(a.date||0) - new Date(b.date||0));
              messageCacheState.cache.set(String(chatId), normalized);
            }
          }
        }

        const rawSynced = safeJsonParse(localStorage.getItem(MESSAGE_SYNC_KEY));
        if (rawSynced && typeof rawSynced === 'object'){
          for (const [chatId, iso] of Object.entries(rawSynced)){
            if (!iso) continue;
            messageCacheState.lastSynced.set(String(chatId), String(iso));
          }
        }

        const lastChatRaw = localStorage.getItem(LAST_CHAT_CACHE_KEY);
        if (lastChatRaw){
          messageCacheState.lastChatId = String(lastChatRaw);
        }
      } catch (err){
        console.warn('Failed to load cached messages', err);
      }
    }

    function persistMessagesToStorage(){
      if (!storageAvailable()) return;
      try {
        const payload = {};
        messageCacheState.cache.forEach((messages, chatId)=>{ payload[chatId] = messages; });
        localStorage.setItem(MESSAGE_CACHE_KEY, JSON.stringify(payload));
      } catch (err){
        console.warn('Failed to persist cached messages', err);
      }
    }

    function persistLastSyncedToStorage(){
      if (!storageAvailable()) return;
      try {
        const payload = {};
        messageCacheState.lastSynced.forEach((iso, chatId)=>{ if (iso) payload[chatId] = iso; });
        localStorage.setItem(MESSAGE_SYNC_KEY, JSON.stringify(payload));
      } catch (err){
        console.warn('Failed to persist lastSyncedAt', err);
      }
    }

    function persistLastChatIdToStorage(){
      if (!storageAvailable()) return;
      try {
        if (messageCacheState.lastChatId){
          localStorage.setItem(LAST_CHAT_CACHE_KEY, messageCacheState.lastChatId);
        }else{
          localStorage.removeItem(LAST_CHAT_CACHE_KEY);
        }
      } catch (err){
        console.warn('Failed to persist last chat id', err);
      }
    }

    function formatMessageTimestamp(iso){
      if (!iso) return '';
      const dt = new Date(iso);
      if (Number.isNaN(dt.getTime())) return '';
      return dt.toLocaleString();
    }

    function computeLatestTimestamp(messages = []){
      let latest = null;
      for (const msg of messages){
        if (!msg?.date) continue;
        const dt = new Date(msg.date);
        if (Number.isNaN(dt.getTime())) continue;
        if (!latest || dt > latest) latest = dt;
      }
      return latest ? latest.toISOString() : null;
    }

    function setChatMessagesStatus(text){
      if (!chatMessagesStatusEl) return;
      chatMessagesStatusEl.textContent = text || '';
    }

    function renderChatMessages(chatId, options = {}){
      if (!chatMessagesListEl) return;
      const key = chatId ? String(chatId) : '';
      const messages = key ? (messageCacheState.cache.get(key) || []) : [];
      if (!messages.length){
        if (options.showPlaceholder !== false){
          chatMessagesListEl.innerHTML = `<li class="row"><div>No messages cached.</div></li>`;
        }else{
          chatMessagesListEl.innerHTML = '';
        }
        return;
      }

      chatMessagesListEl.innerHTML = messages.map(msg=>{
        const ts = formatMessageTimestamp(msg.date);
        const sender = msg.sender_id!=null ? `<div class="sub">Sender: ${escapeHtml(String(msg.sender_id))}</div>` : '';
        const reply = msg.reply_to_msg_id!=null ? `<div class="sub">Reply to ${escapeHtml(String(msg.reply_to_msg_id))}</div>` : '';
        const text = escapeHtml(String(msg.text||'')).replace(/\n+/g, '<br />');
        const meta = [sender, reply, ts ? `<div class="sub">${escapeHtml(ts)}</div>` : ''].filter(Boolean).join('');
        const idAttr = msg.id!=null ? ` data-msg-id="${escapeHtml(String(msg.id))}"` : '';
        return `<li class="row"${idAttr}><div><div class="title">${text || '(no text)'}</div>${meta}</div></li>`;
      }).join('');
    }

    function mergeMessages(existing = [], incoming = []){
      const map = new Map();
      const add = (item)=>{
        const normalized = normalizeMessage(item);
        if (!normalized) return;
        const key = normalized.id!=null
          ? `id:${normalized.id}`
          : `dt:${normalized.date||''}:${(normalized.text||'').slice(0,120)}:${normalized.reply_to_msg_id ?? ''}`;
        map.set(key, normalized);
      };
      existing.forEach(add);
      incoming.forEach(add);
      const merged = Array.from(map.values());
      merged.sort((a,b)=> new Date(a.date||0) - new Date(b.date||0));
      if (merged.length > MAX_CACHED_MESSAGES){
        return merged.slice(merged.length - MAX_CACHED_MESSAGES);
      }
      return merged;
    }

    function normalizeMessage(raw){
      if (!raw || typeof raw !== 'object') return null;
      const id = raw.id ?? raw.message_id ?? raw.msg_id ?? null;
      const sender = raw.sender_id ?? raw.from_id ?? raw.user_id ?? raw.author_id ?? null;
      const reply = raw.reply_to_msg_id ?? raw.reply_to_message_id ?? raw.reply_to ?? null;
      let date = raw.date ?? raw.created_at ?? raw.inserted_at ?? null;
      if (date instanceof Date){
        date = date.toISOString();
      } else if (typeof date === 'number'){
        const assumedMs = date > 1e12 ? date : date * 1000;
        const dt = new Date(assumedMs);
        date = Number.isNaN(dt.getTime()) ? null : dt.toISOString();
      } else if (date != null){
        date = String(date);
      }
      const textVal = raw.text ?? raw.message ?? raw.body ?? '';
      return {
        id: id==null ? null : id,
        sender_id: sender==null ? null : sender,
        date,
        text: typeof textVal === 'string' ? textVal : String(textVal ?? ''),
        reply_to_msg_id: reply==null ? null : reply,
      };
    }

    async function ensureChatMessages(chatId, options = {}){
      const key = chatId ? String(chatId) : '';
      if (!key) return [];
      if (messageCacheState.syncing.has(key)){
        return messageCacheState.cache.get(key) || [];
      }
      messageCacheState.syncing.add(key);
      setChatMessagesStatus('Syncing…');
      try {
        return await fetchLatestMessages(key, options);
      } finally {
        messageCacheState.syncing.delete(key);
      }
    }

    async function fetchLatestMessages(chatId, options = {}){
      const key = chatId ? String(chatId) : '';
      if (!key) return [];
      const forceFull = options.forceFull === true;
      const lastSynced = forceFull ? null : (messageCacheState.lastSynced.get(key) || null);

      const params = new URLSearchParams({ chat_id: key, limit: String(MAX_CACHED_MESSAGES) });
      if (lastSynced) params.set('since', lastSynced);

      let response;
      try {
        response = await fetch(`/api/messages-latest?${params.toString()}`, { headers: H.headers() });
      } catch (err){
        throw new Error(err?.message || 'Network error');
      }

      if (!response.ok){
        if (!forceFull && lastSynced){
          return fetchLatestMessages(key, { forceFull: true });
        }
        const body = await response.text().catch(()=> '');
        const message = body || `Request failed (${response.status})`;
        const error = new Error(message);
        error.status = response.status;
        throw error;
      }

      const raw = await response.json().catch(()=> []);
      if (!Array.isArray(raw)){
        return messageCacheState.cache.get(key) || [];
      }

      const normalizedIncoming = raw.map(normalizeMessage).filter(Boolean);
      const base = (!lastSynced || forceFull) ? [] : (messageCacheState.cache.get(key) || []);
      const merged = mergeMessages(base, normalizedIncoming);
      if (!merged.length && base.length){
        setChatMessagesStatus('No messages found.');
        return base;
      }

      const latestIso = computeLatestTimestamp(merged) || lastSynced;
      messageCacheState.cache.set(key, merged);
      if (latestIso){
        messageCacheState.lastSynced.set(key, latestIso);
      }
      persistMessagesToStorage();
      persistLastSyncedToStorage();
      renderChatMessages(key);
      if (latestIso){
        setChatMessagesStatus(`Synced ${formatMessageTimestamp(latestIso)}`);
      } else if (!merged.length){
        setChatMessagesStatus('No messages found.');
      } else {
        setChatMessagesStatus('Sync complete.');
      }
      return merged;
    }

    function handleChatSelection(chatId, options = {}){
      const key = chatId ? String(chatId) : '';
      if (!key) return;
      if (messageCacheState.lastChatId !== key){
        setActiveChat(key);
        messageCacheState.lastChatId = key;
        persistLastChatIdToStorage();
      }

      const cached = messageCacheState.cache.get(key) || [];
      renderChatMessages(key, { showPlaceholder: options.showPlaceholder !== false });
      if (cached.length){
        const iso = messageCacheState.lastSynced.get(key) || computeLatestTimestamp(cached);
        if (iso) setChatMessagesStatus(`Cached up to ${formatMessageTimestamp(iso)}`);
        else setChatMessagesStatus('Showing cached messages');
      } else {
        setChatMessagesStatus('No cached messages yet.');
      }

      if (!options.skipSync){
        ensureChatMessages(key, { forceFull: options.forceFull === true }).catch(err => {
          console.warn('chat message sync failed', err);
          const reason = err?.message || 'Unknown error';
          setChatMessagesStatus(`Failed to sync (${reason})`);
        });
      }
      syncStatusToolFromActiveChat();
    }

    function restoreCachedMessagesOnInit(){
      if (!messageCacheState.lastChatId && messageCacheState.cache.size){
        const firstKey = messageCacheState.cache.keys().next().value;
        if (firstKey){
          messageCacheState.lastChatId = String(firstKey);
          persistLastChatIdToStorage();
        }
      }
      if (!messageCacheState.lastChatId){
        if (chatMessagesListEl) chatMessagesListEl.innerHTML = '';
        setChatMessagesStatus('');
        return;
      }
      handleChatSelection(messageCacheState.lastChatId);
    }

    /* ---------- Send a message (Full-screen chooser) ---------- */
    const openSendChooser   = document.getElementById('openSendChooser');
    const sendChooserFull   = document.getElementById('sendChooserFull');
    const cancelSendSelBtn  = document.getElementById('cancelSendSelection');
    const confirmSendSelBtn = document.getElementById('confirmSendSelection');
    const sendSearch        = document.getElementById('sendSearch');
    const sendStatusFilter  = document.getElementById('sendStatusFilter');
    const sendChatsList     = document.getElementById('sendChatsList');

    const sendCompose       = document.getElementById('sendCompose');
    const sendChosenChips   = document.getElementById('sendChosenChips');
    const sendChosenSummary = document.getElementById('sendChosenSummary');

    let sendSelected = new Set(); // chat ids as strings
    let chatsCache = [];          // filled by loadChats()

    function openChooser(){
      // ensure chats are loaded
      (async ()=>{
        if (!Array.isArray(chatsCache) || chatsCache.length === 0) { await loadChats(); }
        renderSendList();
        confirmSendSelBtn.disabled = (sendSelected.size === 0);
        sendChooserFull.setAttribute('aria-hidden','false');
      })();
    }
    function closeChooser(){
      sendChooserFull.setAttribute('aria-hidden','true');
    }

    function renderSendList(){
      const q = (sendSearch.value||'').trim().toLowerCase();
      const f = (sendStatusFilter.value||'').trim();

      const items = (chatsCache||[]).filter(c=>{
        const matchesQ = !q || String(c.id).includes(q) ||
          (c.title||'').toLowerCase().includes(q) || (c.username||'').toLowerCase().includes(q);
        const matchesS = !f || (c.status === f);
        return matchesQ && matchesS;
      });

      if(!items.length){
        sendChatsList.innerHTML = `<li class="chooser-row"><div class="hint" style="grid-column:1/-1">No chats found.</div></li>`;
        return;
      }

      sendChatsList.innerHTML = items.map(c=>{
        const id = String(c.id);
        const checked = sendSelected.has(id) ? 'checked' : '';
        const uname = c.username ? `@${c.username}` : '';
        const status = c.status || '—';
        return `<li class="chooser-row" data-id="${id}">
          <input type="checkbox" class="send-tick" ${checked} />
          <div>
            <div class="title">${c.title || '(no title)'}</div>
            <div class="sub">${uname ? uname+' • ' : ''}${id}</div>
          </div>
          <div class="status-pill">${status}</div>
        </li>`;
      }).join('');

      sendChatsList.querySelectorAll('.chooser-row').forEach(li=>{
        const id = li.getAttribute('data-id');
        const tick = li.querySelector('.send-tick');
        tick.addEventListener('change', ()=>{
          if (tick.checked) sendSelected.add(id); else sendSelected.delete(id);
          confirmSendSelBtn.disabled = (sendSelected.size === 0);
          updateChosenSummaryPreview();
        });
        li.addEventListener('click', (e)=>{
          if (e.target === tick) return;
          tick.checked = !tick.checked; tick.dispatchEvent(new Event('change'));
        });
      });
    }

    function updateChosenSummaryPreview(){
      const count = sendSelected.size;
      sendChosenSummary.value = count ? `${count} chat${count>1?'s':''} selected` : 'No chats selected';
    }

    function showCompose(){
      const ids = Array.from(sendSelected);
      const map = new Map(chatsCache.map(c=>[String(c.id), c]));
      sendChosenChips.innerHTML = ids.map(id=>{
        const c = map.get(String(id)) || { title:'(unknown)', id };
        return `<span class="chip" data-id="${id}">
          ${c.title || '(no title)'} <span class="sub">• ${id}</span>
          <span class="x" title="Remove">✕</span>
        </span>`;
      }).join('');

      sendChosenChips.querySelectorAll('.chip .x').forEach(x=>{
        x.addEventListener('click', ()=>{
          const chip = x.closest('.chip'); const id = chip.getAttribute('data-id');
          sendSelected.delete(String(id)); chip.remove(); updateChosenSummaryPreview();
          if (sendSelected.size === 0){ sendCompose.style.display='none'; }
        });
      });

      sendCompose.style.display = ids.length ? 'block' : 'none';
      updateChosenSummaryPreview();
    }

    openSendChooser.addEventListener('click', openChooser);
    cancelSendSelBtn.addEventListener('click', closeChooser);
    confirmSendSelBtn.addEventListener('click', ()=>{ closeChooser(); showCompose(); });

    sendSearch.addEventListener('input', renderSendList);
    sendStatusFilter.addEventListener('change', renderSendList);

    /* Send → final confirm popup */
    const sendMessageBtn   = document.getElementById('sendMessageBtn');
    const sendConfirm      = document.getElementById('sendConfirm');
    const sendConfirmMsg   = document.getElementById('sendConfirmMsg');
    const sendConfirmList  = document.getElementById('sendConfirmList');
    const sendConfirmCancel= document.getElementById('sendConfirmCancel');
    const sendConfirmGo    = document.getElementById('sendConfirmGo');

    function openFinalConfirm(){
      const msg = (document.getElementById('sendText').value || '').trim();
      const ids = Array.from(sendSelected);
      if (!ids.length){ alert('Select at least one chat first.'); return; }
      if (!msg){ alert('Write a message first.'); return; }
      sendConfirmMsg.textContent = msg;

      const map = new Map(chatsCache.map(c=>[String(c.id), c]));
      sendConfirmList.innerHTML = ids.map(id=>{
        const c = map.get(String(id)) || { title:'(unknown)', id, status:'—' };
        const uname = c.username ? `@${c.username}` : '';
        const status = c.status || '—';
        return `<li class="row">
          <div>
            <div class="title">${c.title || '(no title)'}</div>
            <div class="sub">${uname ? uname+' • ' : ''}${id}</div>
          </div>
          <div class="status-pill">${status}</div>
        </li>`;
      }).join('');
      sendConfirm.style.display = 'flex';
    }
    function closeFinalConfirm(){ sendConfirm.style.display = 'none'; }

    sendMessageBtn?.addEventListener('click', openFinalConfirm);
    sendConfirmCancel?.addEventListener('click', closeFinalConfirm);
sendConfirmGo?.addEventListener('click', async ()=>{
  const msg = (document.getElementById('sendText').value || '').trim();
  const ids = Array.from(sendSelected);
  if (!ids.length) { alert('Select at least one chat first.'); return; }
  if (!msg) { alert('Write a message first.'); return; }

  try{
    const r = await fetch('/api/send-message', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...H.headers(), // adds Telegram identity headers for backend auth
      },
      body: JSON.stringify({
        chat_ids: ids,
        message: msg,
        parse_mode: 'HTML',
        disable_notification: false,
        preview_only: false
      })
    });

    const raw = await r.text();
    let data;
    try {
      data = JSON.parse(raw);
    } catch {
      console.error('Non-JSON error body from server:', raw);
      alert(`Send failed (${r.status}): ${raw.slice(0,300)}`);
      return;
    }

    if (!r.ok) {
      console.error('send-message failed', r.status, data);
      alert(`Send failed (${r.status}): ${data?.message || data?.error || 'Unknown error'}`);
      return;
    }

    const sent = data?.sent ?? 0;
    const failed = data?.failed ?? 0;

    // Close popup and give feedback
    closeFinalConfirm();

    if (failed > 0) {
      // Show per-chat errors in console to help debugging
      console.warn('Some chats failed:', data?.results?.filter(x=>x.status!=='ok'));
      alert(`Sent to ${sent} chat${sent!==1?'s':''}; failed ${failed}. Check console for details.`);
    } else {
      alert(`Successfully sent to ${sent} chat${sent!==1?'s':''}.`);
    }

    // (Optional) Clear the message box after successful send
    // document.getElementById('sendText').value = '';

  } catch (e){
    console.error('send-message network error', e);
    alert(`Network error: ${e?.message || e}`);
  }
});
    
    // 🔍 Live search and status filter handlers
    const chatsList = document.getElementById('chats');
    const statusFilterEl = document.getElementById('statusFilter');
    const grantFilterEl = document.getElementById('grantFilter');
    const grantSelectEl = document.getElementById('grantSelect');
    const editGrantBtn = document.getElementById('editGrantBtn');
    const saveGrantBtn = document.getElementById('saveGrant');
    const cancelGrantBtn = document.getElementById('cancelGrant');
    const grantCancelRow = document.getElementById('grantCancelRow');
    const statusOutEl = document.getElementById('statusOut');
    const grantOutEl = document.getElementById('grantOut');
    const chatIdStatusInput = document.getElementById('chatIdStatus');
    const chatIdGrantInput = document.getElementById('chatIdGrant');
    let grantsCache = [];
    let grantsPromise = null;
    let statusOriginalValue = '';
    let grantOriginalValue = '';
    let pendingGrantValue = '';
    let editingStatus = false;
    let editingGrant = false;

    const scheduleChatsReload = debounce(()=>loadChats(), 220);
    document.getElementById('searchChats').addEventListener('input', renderChats);
    statusFilterEl?.addEventListener('change', ()=>{
      renderChats();
      scheduleChatsReload();
    });
    grantFilterEl?.addEventListener('change', ()=>{
      renderChats();
      scheduleChatsReload();
    });


        /* ---------- Chats dashboard & data ---------- */

    async function loadChats(options = {}){
      const silent = options?.silent === true;
      if (!silent) {
        chatsList.innerHTML = `<li class="row"><div>Loading…</div></li>`;
      }

      const url = `/api/chats`;

    
      try{
        const r = await fetch(url, { headers:H.headers() });
        const data = await r.json().catch(()=>null);
        if(!r.ok){
          const errMsg = (data && (data.error || data.details)) || 'unknown';
          chatsList.innerHTML = `<li class="row"><div>Server error (${r.status}): ${errMsg}</div></li>`;
          chatsCache = [];
          return;
        }

        const payload = Array.isArray(data?.chats) ? data.chats : Array.isArray(data) ? data : [];
        chatsCache = payload.map(c => {
          const grantObj = c.grant || (c.grant_id && c.grant_name ? { id: c.grant_id, name: c.grant_name } : null);
          const grantId = grantObj?.id ?? c.grant_id ?? null;
          const grantName = grantObj?.name ?? c.grant_name ?? null;
          return {
            ...c,
            status: c.status || '—',
            status_updated_at: c.status_updated_at || null,
            grant: grantObj,
            grant_id: grantId,
            grant_name: grantName
          };
        });
        
        renderChats();
        syncStatusToolFromActiveChat();
        if (typeof renderSendList === 'function') renderSendList();
        if (typeof populateAiChatSelect === 'function') {
          try { populateAiChatSelect(); } catch (_) {}
        }

        if (chatsCache.length){
          await batchLoadStatuses(chatsCache.slice(0, 50).map(c=>c.id));
        }
      }catch(e){
        chatsList.innerHTML = `<li class="row"><div>Network/JS error: ${e.message||e}</div></li>`;
        chatsCache = [];
      }
    }

    function setGrantSelectValue(value){
      pendingGrantValue = value ? String(value) : '';
      if (!grantSelectEl) return;
      const opts = Array.from(grantSelectEl.options || []);
      const has = opts.some(opt => opt.value === pendingGrantValue);
      grantSelectEl.value = has ? pendingGrantValue : '';
    }

    async function ensureGrantOptionsLoaded(){
      if (grantsCache.length) {
        if (grantSelectEl && grantSelectEl.disabled && editingGrant) grantSelectEl.disabled = false;
        setGrantSelectValue(pendingGrantValue);
        return grantsCache;
      }
      if (grantsPromise) return grantsPromise;
      grantsPromise = (async () => {
        try {
          const r = await fetch('/api/grants', { headers: H.headers() });
          const data = await r.json().catch(()=>({}));
          if (!r.ok) throw new Error(data?.error || data?.details || 'failed_to_load_grants');
          const list = Array.isArray(data?.grants) ? data.grants : [];
          grantsCache = list;
          if (grantSelectEl){
            grantSelectEl.innerHTML = '<option value="">— None —</option>' +
              list.map(g => `<option value="${escapeHtml(String(g.id))}">${escapeHtml(g?.name || '')}</option>`).join('');
            grantSelectEl.disabled = !editingGrant;
            setGrantSelectValue(pendingGrantValue);
          }
          return list;
        } catch (err) {
          console.error('Failed to load grants', err);
          if (grantSelectEl && editingGrant) grantSelectEl.disabled = false;
          return [];
        } finally {
          grantsPromise = null;
        }
      })();
      return grantsPromise;
    }

    function syncStatusToolFromActiveChat(){
      const chat = getActiveChat();
      const chatId = chat?.id != null ? String(chat.id) : '';
      if (chat?.id != null){
        if (chatIdStatusInput) chatIdStatusInput.value = chatId;
        if (chatIdGrantInput) chatIdGrantInput.value = chatId;
      }
      if (statusSel){
        if (chat?.status){
          const desired = String(chat.status);
          const has = Array.from(statusSel.options || []).some(opt => opt.value === desired);
          if (has) statusSel.value = desired;
          else if (statusSel.options && statusSel.options.length) statusSel.selectedIndex = 0;
        } else if (statusSel.options && statusSel.options.length){
          statusSel.selectedIndex = 0;
        }
        statusOriginalValue = statusSel.value || '';
      }
      if (statusOutEl){
        let display = chat ? H.fmtStatus(chat.status) : '—';
        if (chat?.status === 'SoW signed'){ const d = daysSince(chat.status_updated_at); if (d) display += ` · ${d}`; }
        statusOutEl.textContent = display;
      }
      const grantId = chat?.grant_id ? String(chat.grant_id) : '';
      grantOriginalValue = grantId;
      setGrantSelectValue(grantId);
      if (grantOutEl){
        const grantName = chat?.grant_name || chat?.grant?.name || '';
        grantOutEl.textContent = grantName || '— None —';
      }
      setStatusEditing(false);
      setGrantEditing(false);
    }

    function daysSince(dateStr){
      if(!dateStr) return null;
      const then = new Date(dateStr); if(isNaN(then)) return null;
      const d = Math.floor((Date.now() - then.getTime()) / (1000*60*60*24));
      return d>=0 ? `${d}d` : null;
    }

    function renderChats(){
      const q = document.getElementById('searchChats').value.trim().toLowerCase();
      const statusValue = (statusFilterEl?.value || '').trim();
      const grantValue = (grantFilterEl?.value || '').trim();
      const items = (chatsCache || []).filter(c=>{
        const matchesQ = !q || String(c.id).includes(q) ||
          (c.title||'').toLowerCase().includes(q) || (c.username||'').toLowerCase().includes(q);
        const matchesS = !statusValue || (c.status === statusValue);
        const grantName = c.grant_name || c.grant?.name || '';
        const matchesG = !grantValue || grantName === grantValue;
        return matchesQ && matchesS && matchesG;
      });

      if(!items.length){
        const hasFilters = Boolean(q || statusValue || grantValue);
        const message = hasFilters ? 'No chats match the current filters.' : 'No chats available.';
        chatsList.innerHTML = `<li class="row"><div>${message}</div></li>`;
        return;
      }

      chatsList.innerHTML = items.map(c => {
        const parts = [];
        if (c.username) parts.push(`@${c.username}`);
        parts.push(String(c.id));
        let badgeText = H.fmtStatus(c.status);
        if (c.status === 'SoW signed') { const d = daysSince(c.status_updated_at); if (d) badgeText += ` · ${d}`; }
        const grantName = c.grant_name || c.grant?.name || '';
        const grantHtml = grantName ? `<div><span class="grant-pill">${escapeHtml(grantName)}</span></div>` : '';
        return `<li class="row" data-id="${escapeHtml(String(c.id))}">
          <div>
             <div class="title">${escapeHtml(c.title || '(no title)')}</div>
            <div class="sub">${escapeHtml(parts.join(' • '))}</div>
          </div>
          <div class="status-stack">
            <div class="status-pill">${escapeHtml(badgeText)}</div>
            ${grantHtml}
          </div>
        </li>`;
      }).join('');

      chatsList.querySelectorAll('.row').forEach(li=>{
        li.addEventListener('click', async ()=>{
          const id = li.getAttribute('data-id');
          H.pickChat(id);
          chatsList.querySelectorAll('.row').forEach(x=>x.style.outline='none');
          li.style.outline='2px solid rgba(194,123,255,.6)';
          await fetchAndApplyStatus(id, li.querySelector('.status-pill'));
        });
      });
      const highlightId = activeChatId || messageCacheState.lastChatId;
      if (highlightId){
        const stored = chatsList.querySelector(`.row[data-id="${highlightId}"]`);
        if (stored) stored.style.outline='2px solid rgba(194,123,255,.6)';
      }
    }

    async function fetchAndApplyStatus(chatId, badgeEl){
      try{
        const r = await fetch(`/api/status-auto?chat_id=${encodeURIComponent(chatId)}&limit=300`, { headers:H.headers() });
        const data = await r.json().catch(()=>({}));
        if(!r.ok) return;
        const s = data?.status || data?.text || '—';
        const updated_at = data?.status_updated_at || null;

        const idx = chatsCache.findIndex(x=>String(x.id)===String(chatId));
        if(idx>=0){ chatsCache[idx].status = s; chatsCache[idx].status_updated_at = updated_at; }
        if (String(chatId) === String(activeChatId)){
          syncStatusToolFromActiveChat();
        }

        if (badgeEl){
          let txt = s;
          if (s==='SoW signed'){ const d = daysSince(updated_at); if (d) txt += ` · ${d}`; }
          badgeEl.textContent = txt;
        }
      }catch(_){}
    }

    async function batchLoadStatuses(ids){
      for (const id of ids){
        const badge = document.querySelector(`.row[data-id="${id}"] .status-pill`);
        await fetchAndApplyStatus(id, badge);
      }
    }

    /* Timelines */
    async function loadTimelines(){
      const tp = document.getElementById('timelineProduct');
      const tc = document.getElementById('timelineCampaign');
      const setLoading = (el, msg) => { el.innerHTML = `<div class="bar"></div><div class="hint">${msg}</div>`; };
      setLoading(tp, 'Loading…'); setLoading(tc, 'Loading…');
      try{
        const [rp, rc] = await Promise.all([
          fetch('/api/timeline-product',  { headers:H.headers() }),
          fetch('/api/timeline-campaign', { headers:H.headers() })
        ]);
        const jp = await rp.json().catch(()=>({})); const jc = await rc.json().catch(()=>({}));
        const render = (el, ok, payload) => {
          if (!ok) { el.innerHTML = `<div class="bar"></div><div class="hint">Error: ${(payload&&payload.error)||'server error'}</div>`; return; }
          const items = payload.items || [];
          if (!items.length){ el.innerHTML = `<div class="bar"></div><div class="hint">No mentions found.</div>`; return; }
          el.innerHTML = `<div class="bar"></div><ul style="margin:6px 0 0; padding-left:16px">${items.map(i=>`<li>${i.label}</li>`).join('')}</ul>`;
        };
        render(tp, rp.ok, jp); render(tc, rc.ok, jc);
      }catch(e){
        tp.innerHTML = `<div class="bar"></div><div class="hint">Error: ${e.message||e}</div>`;
        tc.innerHTML = `<div class="bar"></div><div class="hint">Error: ${e.message||e}</div>`;
      }
    }

    /* SUMMARY */
    document.getElementById('doSummary').onclick = async () => {
      const id = document.getElementById('chatIdSum').value.trim();
      if (!id) return alert('Enter chat_id');
      const out = document.getElementById('summaryOut');
      out.textContent = 'Summarizing…';
      try {
        const r = await fetch(`/api/summary?chat_id=${encodeURIComponent(id)}`, { headers: H.headers() });
        const data = await r.json().catch(()=>({}));
        if (!r.ok) { out.textContent = `Server error (${r.status}): ${data?.error || 'Unknown error'}${data?.stage ? ` [${data.stage}]` : ''}`; return; }
        out.textContent = data.text || '(no text)';
      } catch (e) { out.textContent = `Network/JS error: ${e.message || e}`; }
    };

    /* STATUS — auto */
    document.getElementById('getStatus').onclick = async ()=>{
      const id = (chatIdStatusInput?.value || '').trim();
      if(!id) return alert('Enter chat_id');
      if (statusOutEl) statusOutEl.textContent = 'Loading…';
      try{
        const r=await fetch(`/api/status-auto?chat_id=${encodeURIComponent(id)}&limit=200`, { headers:H.headers() });
        const data=await r.json().catch(()=>({}));
        if(!r.ok){
          if (statusOutEl) statusOutEl.textContent=`Server error (${r.status}): ${data?.error||'unknown'}`;
          return;
        }
        const s = data?.status || data?.text || '—';
        if (statusOutEl) statusOutEl.textContent = s;
        if (statusSel){
          const has = Array.from(statusSel.options || []).some(opt => opt.value === s);
          if (has) statusSel.value = s;
          statusOriginalValue = statusSel.value || '';
        }
        const idx = chatsCache.findIndex(x=>String(x.id)===String(id));
        if(idx>=0){
          const target = chatsCache[idx];
          target.status = s;
          target.status_updated_at = data?.status_updated_at || target.status_updated_at || null;
          const row = document.querySelector(`.row[data-id="${id}"] .status-pill`);
          if(row) row.textContent = s;
        }
        if (String(id) === String(activeChatId)) syncStatusToolFromActiveChat();
        else setStatusEditing(false);
      }catch(e){
        if (statusOutEl) statusOutEl.textContent = `Error: ${e.message||e}`;
      }
    };

    /* STATUS — manual edit/save */
    const statusSel = document.getElementById('statusSel');
    const editStatusBtn = document.getElementById('editStatusBtn');
    const cancelStatusBtn = document.getElementById('cancelStatus');
    const saveStatusBtn = document.getElementById('saveStatus');

    function setStatusEditing(isEditing){
      editingStatus = isEditing;
      if (statusSel) statusSel.disabled = !isEditing;
      if (saveStatusBtn) saveStatusBtn.disabled = !isEditing;
      if (cancelStatusBtn){
        cancelStatusBtn.disabled = !isEditing;
        cancelStatusBtn.style.visibility = isEditing ? 'visible' : 'hidden';
      }
      if (editStatusBtn) editStatusBtn.disabled = isEditing;
    }

    setStatusEditing(false);

    editStatusBtn?.addEventListener('click', ()=>{
      syncStatusToolFromActiveChat();
      setStatusEditing(true);
      statusSel?.focus();
    });

    cancelStatusBtn?.addEventListener('click', ()=>{
      if (statusSel){
        const has = Array.from(statusSel.options || []).some(opt => opt.value === statusOriginalValue);
        if (has) statusSel.value = statusOriginalValue;
        else if (statusSel.options && statusSel.options.length) statusSel.selectedIndex = 0;
      }
    setStatusEditing(false);
    });

    saveStatusBtn?.addEventListener('click', async ()=>{
      if (!editingStatus) return;
      const id = (chatIdStatusInput?.value || '').trim();
      if (!id){ alert('Enter chat_id'); return; }
      const status = statusSel?.value || '';
      if (statusOutEl) statusOutEl.textContent = 'Saving…';
      saveStatusBtn.disabled = true;
      if (cancelStatusBtn) cancelStatusBtn.disabled = true;
      if (statusSel) statusSel.disabled = true;
      try {
        const r = await fetch('/api/status', {
          method:'POST',
          headers:{'Content-Type':'application/json', ...H.headers()},
          body:JSON.stringify({ chat_id:id, status })
        });
        const txt = await r.text();
        if(!r.ok){
          if (statusOutEl) statusOutEl.textContent = `Server error (${r.status}): ${txt||'unknown'}`;
          setStatusEditing(true);
          return;
        }
        if (statusOutEl) statusOutEl.textContent = status;
        const idx = chatsCache.findIndex(x=>String(x.id)===String(id));
        if(idx>=0){
          const target = chatsCache[idx];
          target.status = status;
          target.status_updated_at = new Date().toISOString();
        }
        const badge = document.querySelector(`.row[data-id="${id}"] .status-pill`);
        if (badge){
          let txtDisplay = H.fmtStatus(status);
          const chat = chatsCache.find(x=>String(x.id)===String(id));
          if (chat && chat.status === 'SoW signed'){ const d = daysSince(chat.status_updated_at); if (d) txtDisplay += ` · ${d}`; }
          badge.textContent = txtDisplay;
        }
        statusOriginalValue = statusSel?.value || '';
        renderChats();
        syncStatusToolFromActiveChat();
      }catch(e){
        if (statusOutEl) statusOutEl.textContent = `Error: ${e.message||e}`;
        setStatusEditing(true);
      }
    });

    /* GRANTS — manual edit/save */
    function setGrantEditing(isEditing){
      editingGrant = isEditing;
      if (grantSelectEl) grantSelectEl.disabled = !isEditing;
      if (cancelGrantBtn) cancelGrantBtn.disabled = !isEditing;
      if (grantCancelRow) grantCancelRow.style.display = isEditing ? 'grid' : 'none';
      if (editGrantBtn) editGrantBtn.disabled = isEditing;
    }

    setGrantEditing(false);

    editGrantBtn?.addEventListener('click', async ()=>{
      syncStatusToolFromActiveChat();
      setGrantEditing(true);
      await ensureGrantOptionsLoaded();
      setGrantSelectValue(grantOriginalValue);
      grantSelectEl?.focus();
    });
    
    cancelGrantBtn?.addEventListener('click', ()=>{
      setGrantSelectValue(grantOriginalValue);
      setGrantEditing(false);
    });

    saveGrantBtn?.addEventListener('click', async ()=>{
      if (!editingGrant) return;
      const chat = getActiveChat();
      const fallbackId = (chatIdGrantInput?.value || '').trim();
      const chatId = chat?.id != null ? String(chat.id) : (fallbackId ? String(fallbackId) : null);
      if (!chatId){ alert('Enter chat_id'); return; }
      await ensureGrantOptionsLoaded();
      const selected = grantSelectEl?.value || '';
      const method = selected ? 'POST' : 'DELETE';
      const payload = selected ? { chat_tg_id: chatId, program_id: Number(selected) } : { chat_tg_id: chatId };
      const body = JSON.stringify(payload);
      const buttons = [saveGrantBtn, cancelGrantBtn, grantSelectEl];
      buttons.forEach(btn => { if (btn) btn.disabled = true; });
      if (grantOutEl) grantOutEl.textContent = 'Saving…';
      try {
        const r = await fetch('/api/assign-grant', {
          method,
          headers: { 'Content-Type': 'application/json', ...H.headers() },
          body
        });
        const data = await r.json().catch(()=>({}));
        if (!r.ok){
          const msg = data?.error || data?.details || `Request failed (${r.status})`;
          alert(`Failed to save grant: ${msg}`);
          setGrantSelectValue(grantOriginalValue);
          setGrantEditing(true);
          if (grantOutEl){
            const option = grantSelectEl ? grantSelectEl.options[grantSelectEl.selectedIndex] : null;
            grantOutEl.textContent = grantOriginalValue ? (option?.textContent || '— None —') : '— None —';
          }
          return;
        }
        grantOriginalValue = selected || '';
        setGrantSelectValue(grantOriginalValue);
        setGrantEditing(false);
        if (grantOutEl){
          const option = grantSelectEl ? grantSelectEl.options[grantSelectEl.selectedIndex] : null;
          grantOutEl.textContent = selected ? (option?.textContent || '— None —') : '— None —';
        }
        await loadChats({ silent: true });
      } catch (err){
        alert(`Failed to save grant: ${err?.message || err}`);
        setGrantSelectValue(grantOriginalValue);
        setGrantEditing(true);
        if (grantOutEl){
          const option = grantSelectEl ? grantSelectEl.options[grantSelectEl.selectedIndex] : null;
          grantOutEl.textContent = grantOriginalValue ? (option?.textContent || '— None —') : '— None —';
        }
      } finally {
        buttons.forEach(btn => { if (btn) btn.disabled = !editingGrant; });
      }
    });

    /* BLURB */
    document.getElementById('getBlurb').onclick = async ()=>{
      const id=document.getElementById('chatIdCompany').value.trim();
      if(!id) return alert('Enter chat_id');
      const out=document.getElementById('blurbOut'); out.textContent='Loading…';
      try{
        const r=await fetch(`/api/company-blurb?chat_id=${encodeURIComponent(id)}`, { headers:H.headers() });
        const data=await r.json().catch(()=>({}));
        if(!r.ok){ out.textContent=`Server error (${r.status}): ${data?.error||'unknown'}`; return; }
        out.textContent = data.text || data.blurb || data.note || 'No blurb found.';
      }catch(e){ out.textContent = `Error: ${e.message||e}`; }
    };

    /* PER-CHAT DATES */
    document.getElementById('getDatesProd').onclick = async ()=>{
      const id=document.getElementById('chatIdDatesProd').value.trim();
      if(!id) return alert('Enter chat_id');
      const out=document.getElementById('datesOutProd'); out.textContent='Loading…';
      try{
        const r=await fetch(`/api/date-product?chat_id=${encodeURIComponent(id)}`, { headers:H.headers() });
        const data=await r.json().catch(()=>({}));
        if(!r.ok){ out.textContent=`Server error (${r.status}): ${data?.error||'unknown'}`; return; }
        out.textContent = data?.text || data?.month || data?.label || 'Unknown';
      }catch(e){ out.textContent = `Error: ${e.message||e}`; }
    };
    document.getElementById('getDatesCamp').onclick = async ()=>{
      const id=document.getElementById('chatIdDatesCamp').value.trim();
      if(!id) return alert('Enter chat_id');
      const out=document.getElementById('datesOutCamp'); out.textContent='Loading…';
      try{
        const r=await fetch(`/api/date-campaign?chat_id=${encodeURIComponent(id)}`, { headers:H.headers() });
        const data=await r.json().catch(()=>({}));
        if(!r.ok){ out.textContent=`Server error (${r.status}): ${data?.error||'unknown'}`; return; }
        out.textContent = data?.text || data?.month || data?.label || 'Unknown';
      }catch(e){ out.textContent = `Error: ${e.message||e}`; }
    };

    /* NEXT STEPS (AI) */
    document.getElementById('getNext').onclick = async ()=>{
      const id = document.getElementById('chatIdNext').value.trim();
      if (!id) return alert('Enter chat_id');
      const out = document.getElementById('nextOut'); out.textContent = 'Thinking…';
      try{
        const r = await fetch(`/api/next-steps?chat_id=${encodeURIComponent(id)}&limit=120`, { headers: H.headers() });
        const data = await r.json().catch(()=>({}));
        if (!r.ok) { out.textContent = `Server error (${r.status}): ${data?.error||'unknown'}${data?.stage?` [${data.stage}]`:''}`; return; }
        out.textContent = data.text || '(no suggestions)';
      }catch(e){ out.textContent = `Error: ${e.message||e}`; }
    };

        /* Team tasks */
    const teamSelectEl = document.getElementById('teamSelect');
    const taskSearchEl = document.getElementById('taskSearch');
    const taskListEl = document.getElementById('taskList');
    const completedListEl = document.getElementById('completedTaskList');
    const taskMessageEl = document.getElementById('taskMessage');
    const completedMessageEl = document.getElementById('completedTasksMessage');
    const newTaskTextEl = document.getElementById('newTaskText');
    const newTaskAssigneeEl = document.getElementById('newTaskAssignee');
    const addTaskBtnEl = document.getElementById('addTaskBtn');
    const newTaskHintEl = document.getElementById('newTaskHint');
    const defaultNewTaskHint = 'Tasks appear for the teammate you assign them to.';

    const teamTasks = {};
    let isHydratingTasks = false;
    let hydrationContext = null;

    function normalizeHandle(handle = ''){
      return String(handle || '').trim().replace(/^@/, '');
    }

      function toLowerHandle(handle = ''){
      const normalized = normalizeHandle(handle);
      return normalized ? normalized.toLowerCase() : '';
    }

    const teammateDirectory = (() => {
      const meta = {};
      const options = document.querySelectorAll('#teamSelect option, #newTaskAssignee option');
      options.forEach(opt => {
        const raw = (opt?.value || '').trim();
        if(!raw) return;
        const username = normalizeHandle(raw);
        if(!username) return;
        const key = username.toLowerCase();
        if(!meta[key]) meta[key] = { username, user_id: null, value: raw };
        if(!meta[key].value) meta[key].value = raw;
        const userIdAttr = opt.getAttribute('data-user-id');
        if(userIdAttr && meta[key].user_id == null){
          const parsed = Number(userIdAttr);
          if(Number.isSafeInteger(parsed)){
            meta[key].user_id = parsed;
          }
        }
      });
      return meta;
    })();

    function ensureTaskMetadata(task, fallbackHandle = ''){
      if(!task) return task;

      if(!task.text && task.description){
        task.text = task.description;
      }

      const derivedHandle = task.username || task.assignee || task.handle || fallbackHandle;
      const normalized = normalizeHandle(derivedHandle);
      if(normalized){
        task.username = normalized;
      }

      if(task.user_id != null){
        const parsedId = Number(task.user_id);
        task.user_id = Number.isSafeInteger(parsedId) ? parsedId : null;
      }

      if(task.user_id == null && normalized){
        const directoryEntry = teammateDirectory[normalized.toLowerCase()];
        if(directoryEntry && directoryEntry.user_id != null){
          task.user_id = directoryEntry.user_id;
        }
      }

      return task;
    }

    function teammateOptionValue(handle = ''){
      const normalized = normalizeHandle(handle);
      if(!normalized) return '';
      const directoryEntry = teammateDirectory[normalized.toLowerCase()];
      if(directoryEntry?.value) return directoryEntry.value;
      const options = document.querySelectorAll('#teamSelect option, #newTaskAssignee option');
      for(const opt of options){
        if(normalizeHandle(opt?.value || '') === normalized){
          return opt.value;
        }
      }
      return handle && handle.startsWith('@') ? handle : `@${normalized}`;
    }

    async function logTaskCompletion(task, teammateHandle = ''){
      const enriched = ensureTaskMetadata(task, teammateHandle);
      if(!enriched) return;

      const normalizedUserId = (typeof enriched.user_id === 'number' && Number.isSafeInteger(enriched.user_id)) ? enriched.user_id : null;
      const payload = {
        tg_username: normalizeHandle(enriched.username),
        tg_user_id: normalizedUserId,
        description: enriched.text || ''
      };

      if(!payload.tg_username || !payload.description){
        console.warn('Skipping task log — incomplete payload', payload);
        return;
      }

      try {
        const response = await fetch('/api/log-task', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', ...H.headers() },
          body: JSON.stringify(payload)
        });

        if(!response.ok){
          const errBody = await response.text().catch(()=> '');
          console.warn('log-task request failed', response.status, errBody);
        }
      } catch (error) {
        console.error('log-task network error', error);
      }
    }

      async function notifyTaskAssignment(assigneeHandle, taskText, taskId){
      const handle = (assigneeHandle || '').trim();
      const text = (taskText || '').trim();
      if(!handle || !text){
        return { ok:false, error:'INVALID_INPUT', message:'Missing handle or task text.' };
      }

      try{
        if(!Array.isArray(chatsCache) || !chatsCache.length){
          await loadChats();
        }
      }catch(e){
        console.warn('Failed to load chats before notifying:', e);
      }

      const normalizedHandle = handle.replace(/^@/, '').toLowerCase();
      const chat = (chatsCache || []).find(c => (c.username || '').toLowerCase() === normalizedHandle);

      if(!chat){
        const msg = `No chat found for ${handle}.`;
        console.warn(msg);
        return { ok:false, error:'NO_CHAT', message: msg };
      }

      const assignerName = user ? [user.first_name, user.last_name].filter(Boolean).join(' ') : '';
      const assignerHandle = user?.username ? `@${user.username}` : '';
      const assigneeLabel = optionLabelFor(handle) || chat.title || handle;

      try{
        const r = await fetch('/api/task-notify', {
          method:'POST',
          headers:{
            'Content-Type':'application/json',
            ...H.headers()
          },
          body: JSON.stringify({
            assignee_chat_id: chat.id,
            assignee_username: chat.username ? `@${chat.username}` : handle,
            assignee_display: assigneeLabel,
            task_text: text,
            task_id: taskId,
            assigner_name: assignerName,
            assigner_username: assignerHandle
          })
        });

        const data = await r.json().catch(()=>({}));
        if(!r.ok){
          console.warn('Task notify failed', r.status, data);
          return { ok:false, error:data?.error || 'SERVER_ERROR', message:data?.message || 'Failed to send notification.' };
        }

        return { ok:true, result:data?.result || null };
      }catch(e){
        console.error('Task notify network error', e);
        return { ok:false, error:'NETWORK_ERROR', message:e?.message || String(e) };
      }
    }
    
    function ensureTeamBucket(id){
      if(!id) return null;
      if(!teamTasks[id]) teamTasks[id] = { active: [], completed: [] };
      return teamTasks[id];
    }

    function sortTeamBuckets(){
      Object.values(teamTasks).forEach(bucket => {
        if(!Array.isArray(bucket.active)) bucket.active = [];
        if(!Array.isArray(bucket.completed)) bucket.completed = [];
        bucket.active.sort((a, b) => {
          const aTime = new Date(a.createdAt || 0).getTime();
          const bTime = new Date(b.createdAt || 0).getTime();
          return bTime - aTime;
        });
        bucket.completed.sort((a, b) => {
          const aTime = new Date(a.completedAt || a.createdAt || 0).getTime();
          const bTime = new Date(b.completedAt || b.createdAt || 0).getTime();
          return bTime - aTime;
        });
      });
    }

    function currentHydrationOption(){
      return hydrationContext?.optionValue || teamSelectEl?.value || '';
    }

    function currentHydrationHandle(){
      if(hydrationContext?.normalizedHandle){
        return hydrationContext.normalizedHandle;
      }
      return normalizeHandle(currentHydrationOption());
    }

    function showActiveTasks(rows = [], optionValue = currentHydrationOption(), normalizedHandle = currentHydrationHandle()){
      if(!optionValue) return;
      const ensureCompletedArray = (bucket) => {
        if(!Array.isArray(bucket.completed)) bucket.completed = [];
      };
      const cleared = new Set();
      const ensureClearedBucket = (value) => {
        const key = value || optionValue;
        const bucket = ensureTeamBucket(key);
        if(!bucket) return bucket;
        if(!cleared.has(key)){
          bucket.active = [];
          ensureCompletedArray(bucket);
          cleared.add(key);
        }
        return bucket;
      };

      ensureClearedBucket(optionValue);

      rows.forEach(row => {
        if(!row) return;
        const rowHandle = normalizeHandle(row.tg_username || normalizedHandle || optionValue);
        const resolvedOptionValue = teammateOptionValue(rowHandle) || optionValue;
        const bucket = ensureClearedBucket(resolvedOptionValue);
        if(!bucket) return;

        const baseId = row.id ?? row.task_id ?? row.taskId ?? row.uuid ?? `task-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;
        const createdAt = row.created_at || row.createdAt || row.assigned_at || null;
        const task = ensureTaskMetadata({
          id: String(baseId),
          text: row.description || row.text || '',
          username: rowHandle,
          user_id: row.tg_user_id ?? row.user_id ?? null,
          createdAt
        }, resolvedOptionValue);
        task.serverId = row.id ?? task.serverId ?? null;
        if(!task.createdAt){
          task.createdAt = createdAt || new Date().toISOString();
        }
        bucket.active.push(task);
      });

      sortTeamBuckets();
    }

    function showPastTasks(rows = [], optionValue = currentHydrationOption(), normalizedHandle = currentHydrationHandle()){
      if(!optionValue) return;
      const ensureActiveArray = (bucket) => {
        if(!Array.isArray(bucket.active)) bucket.active = [];
      };
      const cleared = new Set();
      const ensureClearedBucket = (value) => {
        const key = value || optionValue;
        const bucket = ensureTeamBucket(key);
        if(!bucket) return bucket;
        ensureActiveArray(bucket);
        if(!Array.isArray(bucket.completed)) bucket.completed = [];
        if(!cleared.has(key)){
          bucket.completed = [];
          cleared.add(key);
        }
        return bucket;
      };

      ensureClearedBucket(optionValue);

      rows.forEach(row => {
        if(!row) return;
        const rowHandle = normalizeHandle(row.tg_username || normalizedHandle || optionValue);
        const resolvedOptionValue = teammateOptionValue(rowHandle) || optionValue;
        const bucket = ensureClearedBucket(resolvedOptionValue);
        if(!bucket) return;

        const baseId = row.id ?? row.task_id ?? row.taskId ?? row.uuid ?? `past-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;
        const createdAt = row.created_at || row.createdAt || null;
        const completedAt = row.completed_at || row.completedAt || null;
        const task = ensureTaskMetadata({
          id: String(baseId),
          text: row.description || row.text || '',
          username: rowHandle,
          user_id: row.tg_user_id ?? row.user_id ?? null,
          createdAt,
          completedAt
        }, resolvedOptionValue);
        task.serverId = row.id ?? task.serverId ?? null;
        if(!task.completedAt){
          task.completedAt = completedAt || createdAt || new Date().toISOString();
        }
        if(!task.createdAt && createdAt){
          task.createdAt = createdAt;
        }
        bucket.completed.push(task);
      });

      sortTeamBuckets();
    }

    function escapeHtml(str = ''){
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function formatDateTime(iso){
      if(!iso) return '';
      const dt = new Date(iso);
      if(Number.isNaN(dt.getTime())) return '';
      return dt.toLocaleString(undefined, { dateStyle: 'medium', timeStyle: 'short' });
    }

    function optionLabelFor(value){
      const opts = document.querySelectorAll('#teamSelect option, #newTaskAssignee option');
      for(const opt of opts){
        if(opt.value === value) return opt.textContent.trim();
      }
      return value;
    }

    async function hydrateTasksFromServer(teammateHandle = ''){
      const normalizedHandle = normalizeHandle(teammateHandle || teamSelectEl?.value || '');
      if(!normalizedHandle){
        renderTasks();
        return;
      }

      const optionValue = teammateOptionValue(normalizedHandle);
      if(!optionValue){
        renderTasks();
        return;
      }

      if(isHydratingTasks) return;
      isHydratingTasks = true;

      const lowerHandle = toLowerHandle(normalizedHandle);
      hydrationContext = { optionValue, normalizedHandle };

      try{
        if(teamSelectEl && teamSelectEl.value === optionValue){
          if(taskMessageEl){
            taskMessageEl.textContent = 'Loading tasks…';
            taskMessageEl.style.display = 'block';
            taskMessageEl.dataset.sticky = 'true';
          }
          if(completedMessageEl){
            completedMessageEl.textContent = 'Loading past tasks…';
            completedMessageEl.style.display = 'block';
            completedMessageEl.dataset.sticky = 'true';
          }
        }

        const [activeResponse, pastResponse] = await Promise.all([
          fetch(`/api/team-tasks?username=${encodeURIComponent(lowerHandle)}`, { headers: H.headers() }),
          fetch(`/api/team-tasks?username=${encodeURIComponent(lowerHandle)}&past=true`, { headers: H.headers() })
        ]);

        const [activeData, pastData] = await Promise.all([
          activeResponse.json().catch(()=>({})),
          pastResponse.json().catch(()=>({}))
        ]);

        const activeRows = Array.isArray(activeData?.tasks)
          ? activeData.tasks
          : Array.isArray(activeData?.active)
            ? activeData.active
            : [];
        activeData.tasks = Array.isArray(activeRows) ? activeRows : [];

        const pastRows = Array.isArray(pastData?.pastTasks)
          ? pastData.pastTasks
          : [];
        pastData.pastTasks = Array.isArray(pastRows) ? pastRows : [];

        showActiveTasks(activeResponse.ok ? activeData.tasks : []);
        if(activeResponse.ok){
          if(teamSelectEl && teamSelectEl.value === optionValue && taskMessageEl){
            delete taskMessageEl.dataset.sticky;
          }
          
        }else{
          console.warn('Failed to load tasks from server', activeResponse.status, activeData);
          if(teamSelectEl && teamSelectEl.value === optionValue && taskMessageEl){
            taskMessageEl.textContent = 'Failed to load tasks. Please try again.';
            taskMessageEl.style.display = 'block';
            taskMessageEl.dataset.sticky = 'true';
          }
        }

        showPastTasks(pastResponse.ok ? pastData.pastTasks : []);
        if(pastResponse.ok){
          if(teamSelectEl && teamSelectEl.value === optionValue && completedMessageEl){
            delete completedMessageEl.dataset.sticky;
          }
        }else{
          console.warn('Failed to load past tasks from server', pastResponse.status, pastData);
          if(teamSelectEl && teamSelectEl.value === optionValue && completedMessageEl){
            completedMessageEl.textContent = 'Failed to load past tasks. Please try again.';
            completedMessageEl.style.display = 'block';
            completedMessageEl.dataset.sticky = 'true';
          }
        }

        renderTasks();
      }catch(e){
        console.error('Failed to hydrate tasks from server', e);
        if(teamSelectEl && teamSelectEl.value === optionValue){
          if(taskMessageEl){
            taskMessageEl.textContent = 'Failed to load tasks. Please try again.';
            taskMessageEl.style.display = 'block';
            taskMessageEl.dataset.sticky = 'true';
          }
          if(completedMessageEl){
            completedMessageEl.textContent = 'Failed to load past tasks. Please try again.';
            completedMessageEl.style.display = 'block';
            completedMessageEl.dataset.sticky = 'true';
          }
        }
      }finally{
        hydrationContext = null;
        isHydratingTasks = false;
      }
    }

    function renderTasks(){
      if(!taskListEl || !completedListEl) return;
      const teammate = teamSelectEl?.value || '';
      const query = (taskSearchEl?.value || '').trim().toLowerCase();

      taskListEl.innerHTML = '';
      completedListEl.innerHTML = '';

      if(!teammate){
        if(taskMessageEl) delete taskMessageEl.dataset.sticky;
        if(completedMessageEl) delete completedMessageEl.dataset.sticky;
      }

      if(taskMessageEl){
        const sticky = taskMessageEl?.dataset?.sticky === 'true';
        if(!sticky){
          taskMessageEl.textContent = 'Choose a teammate to see their tasks.';
          taskMessageEl.style.display = teammate ? 'none' : 'block';
        }
      }
      if(completedMessageEl){
        const sticky = completedMessageEl?.dataset?.sticky === 'true';
        if(!sticky){
          completedMessageEl.textContent = 'Choose a teammate to see their tasks.';
          completedMessageEl.style.display = teammate ? 'none' : 'block';
        }
      }

      if(!teammate) return;

      const bucket = ensureTeamBucket(teammate);
      const activeWithMeta = bucket.active.map(task => ensureTaskMetadata(task, teammate));
      const completedWithMeta = bucket.completed.map(task => ensureTaskMetadata(task, teammate));
      const filteredActive = activeWithMeta.filter(task => !query || (task.text || '').toLowerCase().includes(query));
      const filteredCompleted = completedWithMeta.filter(task => !query || (task.text || '').toLowerCase().includes(query));

      if(!filteredActive.length){
        taskListEl.innerHTML = `<li class="task-empty">${query ? 'No tasks match your search.' : 'No tasks yet — assign one below.'}</li>`;
      } else {
        taskListEl.innerHTML = filteredActive.map(task => `<li class="task-item"><label><input type="checkbox" class="task-check" data-task-id="${task.id}" /><span>${escapeHtml(task.text)}</span></label></li>`).join('');
      }

      if(!filteredCompleted.length){
        completedListEl.innerHTML = `<li class="task-empty">${query ? 'No completed tasks match your search.' : 'No completed tasks yet.'}</li>`;
      } else {
        completedListEl.innerHTML = filteredCompleted.map(task => `<li class="task-item completed"><div><div>${escapeHtml(task.text)}</div><div class="task-meta">Completed ${formatDateTime(task.completedAt)}</div></div></li>`).join('');
      }

      taskListEl.querySelectorAll('.task-check').forEach(box => {
        box.addEventListener('change', (event) => {
          if(!event.target.checked) return;
          const id = event.target.getAttribute('data-task-id');
          completeTask(teammate, id);
        });
      });
    }

    async function persistTaskAssignment(task, teammateHandle = ''){
      const enriched = ensureTaskMetadata({ ...task }, teammateHandle);
      const payload = {
        tg_username: normalizeHandle(enriched?.username || teammateHandle),
        tg_user_id: (typeof enriched?.user_id === 'number' && Number.isSafeInteger(enriched.user_id)) ? enriched.user_id : null,
        description: enriched?.text || ''
      };

      if(!payload.tg_username || !payload.description){
        return { ok:false, error:'Missing username or description.' };
      }

      try{
        const response = await fetch('/api/team-tasks', {
          method:'POST',
          headers:{ 'Content-Type':'application/json', ...H.headers() },
          body: JSON.stringify(payload)
        });
        const data = await response.json().catch(()=>({}));
        if(!response.ok){
          const reason = data?.error || data?.message || `Server error (${response.status})`;
          console.warn('Failed to persist task', response.status, data);
          return { ok:false, error:reason };
        }

        const saved = data?.task || null;
        if(saved){
          task.id = String(saved.id ?? task.id);
          task.serverId = saved.id ?? task.serverId ?? null;
          task.username = saved.tg_username || task.username;
          task.user_id = saved.tg_user_id ?? task.user_id ?? null;
          task.text = saved.description || task.text;
          task.createdAt = saved.created_at || task.createdAt || new Date().toISOString();
          ensureTaskMetadata(task, teammateHandle);
          renderTasks();
        }

        return { ok:true, task:saved };
      }catch(e){
        console.error('persistTaskAssignment error', e);
        return { ok:false, error:e?.message || String(e) };
      }
    }

    async function syncTaskCompletion(task){
      const rawId = task?.serverId ?? task?.id;
      const numericId = Number(rawId);
      if(!Number.isSafeInteger(numericId)) return;
      try{
        const response = await fetch('/api/team-tasks', {
          method:'DELETE',
          headers:{ 'Content-Type':'application/json', ...H.headers() },
          body: JSON.stringify({ id: numericId })
        });
        if(!response.ok){
          const text = await response.text().catch(()=> '');
          console.warn('Failed to remove task from server', response.status, text);
        }
      }catch(e){
        console.error('syncTaskCompletion error', e);
      }
    }

    async function completeTask(teammate, id){
      const bucket = ensureTeamBucket(teammate);
      if(!bucket) return;
      const idx = bucket.active.findIndex(task => String(task.id) === String(id));
      if(idx === -1) return;
      const [task] = bucket.active.splice(idx, 1);
      task.completedAt = new Date().toISOString();
      const completedTask = ensureTaskMetadata(task, teammate);
      bucket.completed.unshift(completedTask);
      renderTasks();
      await Promise.allSettled([
        logTaskCompletion(completedTask, teammate),
        syncTaskCompletion(completedTask)
      ]);
      hydrateTasksFromServer(teammate);
    }

    async function handleAssignTask(){
      if(!newTaskTextEl) return;
      const text = newTaskTextEl.value.trim();
      const assignee = (newTaskAssigneeEl?.value || teamSelectEl?.value || '').trim();

      if(!text){
        if(newTaskHintEl) newTaskHintEl.textContent = 'Please describe the task before assigning it.';
        return;
      }
      if(!assignee){
        if(newTaskHintEl) newTaskHintEl.textContent = 'Please choose who should take this task.';
        return;
      }

      const label = optionLabelFor(assignee);
      const bucket = ensureTeamBucket(assignee);
      const tempId = `temp-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
      const nowIso = new Date().toISOString();
      const task = ensureTaskMetadata({ id: tempId, text, createdAt: nowIso, username: assignee }, assignee);
      task.serverId = task.serverId ?? null;
      bucket.active.unshift(task);
      if(teamSelectEl && teamSelectEl.value === assignee){
        renderTasks();
      }

      if(newTaskHintEl) newTaskHintEl.textContent = `Task assigned to ${label}. Saving…`;

      const saveResult = await persistTaskAssignment(task, assignee);
      if(!saveResult?.ok){
        const reason = String(saveResult?.error || 'Task could not be saved.');
        const idx = bucket.active.indexOf(task);
        if(idx !== -1){
          bucket.active.splice(idx, 1);
        }
        if(teamSelectEl && teamSelectEl.value === assignee){
          renderTasks();
        }
        if(newTaskHintEl) newTaskHintEl.textContent = `Task not saved: ${reason}`;
        return;
      }


      newTaskTextEl.value = '';
      if(newTaskAssigneeEl) newTaskAssigneeEl.value = assignee;

      if(newTaskHintEl) newTaskHintEl.textContent = `Task assigned to ${label}. Sending notification…`;
      if(teamSelectEl && teamSelectEl.value === assignee){
        renderTasks();
      }

      const notifyPromise = notifyTaskAssignment(assignee, task.text, task.id);
      if(newTaskHintEl){
        const result = await notifyPromise;
        if(result?.ok){
          newTaskHintEl.textContent = `Task assigned to ${label}. Notification sent.`;
        }else{
          const reason = result?.message || result?.error || 'Notification failed.';
          newTaskHintEl.textContent = `Task assigned to ${label}. ${reason}`;
        }
      }else{
        await notifyPromise;
      }
      hydrateTasksFromServer(assignee);
    }

    if(addTaskBtnEl) addTaskBtnEl.addEventListener('click', handleAssignTask);
    if(taskSearchEl) taskSearchEl.addEventListener('input', ()=>renderTasks());
    if(teamSelectEl) teamSelectEl.addEventListener('change', ()=>{
      if(taskSearchEl) taskSearchEl.value = '';
      if(newTaskAssigneeEl){
        newTaskAssigneeEl.value = teamSelectEl.value || '';
      }
      renderTasks();
      if(newTaskHintEl) newTaskHintEl.textContent = defaultNewTaskHint;
            hydrateTasksFromServer(teamSelectEl.value || '');
    });
    if(newTaskTextEl) newTaskTextEl.addEventListener('input', ()=>{
      if(newTaskHintEl) newTaskHintEl.textContent = defaultNewTaskHint;
    });
    if(newTaskAssigneeEl) newTaskAssigneeEl.addEventListener('change', ()=>{
      if(newTaskHintEl) newTaskHintEl.textContent = defaultNewTaskHint;
    });
    if(newTaskAssigneeEl && teamSelectEl){
      newTaskAssigneeEl.value = teamSelectEl.value || '';
    }
    if(newTaskHintEl) newTaskHintEl.textContent = defaultNewTaskHint;
    renderTasks();
    hydrateTasksFromServer(teamSelectEl?.value || '');
    
    /* AI Assistant */
    const aiChatSelect = document.getElementById('aiChatSelect');
    const aiPromptInput = document.getElementById('aiPromptInput');
    const aiResult = document.getElementById('aiResult');
    const askAiBtn = document.getElementById('askAiBtn');
    const defaultAiResultText = 'Response will appear here…';
    let aiCachedChats = [];
    let aiCachedChatsPromise = null;

    function resetAiUi(){
      if (aiPromptInput) aiPromptInput.value = '';
      if (aiResult) aiResult.textContent = defaultAiResultText;
      if (askAiBtn) askAiBtn.disabled = false;
    }

    function aiSelectFallbackList(){
      if (Array.isArray(aiCachedChats) && aiCachedChats.length){
        return aiCachedChats;
      }
      if (Array.isArray(chatsCache) && chatsCache.length){
        return chatsCache.map(chat => ({
          id: chat?.id,
          title: chat?.title || '',
          username: chat?.username || '',
        }));
      }
      return [];
    }

    function populateAiChatSelect(list = null, options = {}){
      if (!aiChatSelect) return;
      const previous = options.previousValue ?? aiChatSelect.value ?? '';
      const source = Array.isArray(list) && list.length ? list : aiSelectFallbackList();
      aiChatSelect.innerHTML = '<option value="">Select a chat…</option>';
      (source || []).forEach(chat => {
        const id = String(chat?.id ?? '').trim();
        if (!id) return;
        const title = chat?.title || '(no title)';
        const parts = [title];
        if (chat?.username) parts.push(`@${chat.username}`);
        parts.push(id);
        aiChatSelect.innerHTML += `<option value="${id}">${parts.join(' • ')}</option>`;
      });
      if (previous) {
        const hasPrev = (source || []).some(chat => String(chat?.id ?? '') === previous);
        if (hasPrev) aiChatSelect.value = previous;
      }
    }

    async function loadCachedChatsForAi({ force = false } = {}){
      if (!aiChatSelect) return [];
      if (!force && aiCachedChats.length){
        populateAiChatSelect(aiCachedChats, { previousValue: aiChatSelect.value || '' });
        return aiCachedChats;
      }
      if (aiCachedChatsPromise && !force){
        return aiCachedChatsPromise;
      }

      const previous = aiChatSelect?.value || '';
      aiChatSelect.innerHTML = '<option value="">Loading chats…</option>';

      aiCachedChatsPromise = (async () => {
        try {
          const response = await fetch('/api/cached-chats', { headers: H.headers() });
          const payload = await response.json().catch(() => (response.ok ? [] : {}));
          if (!response.ok){
            const message = payload?.error || `Server error (${response.status})`;
            throw new Error(message);
          }

          const normalized = Array.isArray(payload)
            ? payload
                .map(item => {
                  const rawId = item?.chat_id ?? item?.id ?? '';
                  const id = String(rawId ?? '').trim();
                  if (!id) return null;
                  return {
                    id,
                    title: typeof item?.title === 'string' ? item.title : '',
                    username: typeof item?.username === 'string' ? item.username : '',
                  };
                })
                .filter(Boolean)
            : [];

          aiCachedChats = normalized;
          populateAiChatSelect(aiCachedChats, { previousValue: previous });
          return aiCachedChats;
        } catch (err) {
          console.error('loadCachedChatsForAi error:', err);
          aiCachedChats = [];
          const fallbackList = aiSelectFallbackList();
          if (fallbackList.length){
            populateAiChatSelect(fallbackList, { previousValue: previous });
          } else if (aiChatSelect){
            const message = err?.message || 'Failed to load chats';
            aiChatSelect.innerHTML = `<option value="">${message}</option>`;
          }
          throw err;
        } finally {
          aiCachedChatsPromise = null;
        }
      })();

      return aiCachedChatsPromise;
    }
    
    async function handleAskAi(){
      const chatId = aiChatSelect?.value || '';
      const prompt = aiPromptInput?.value.trim() || '';
      if (!chatId) return alert('Please select a chat');
      if (!prompt) return alert('Please enter a question or prompt');

      if (aiResult) aiResult.textContent = 'Thinking…';
      if (askAiBtn) askAiBtn.disabled = true;
      
      try {
        const r = await fetch('/api/ask-ai', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...H.headers()
            
          },
          body: JSON.stringify({ chat_id: chatId, prompt })
        });
        const data = await r.json().catch(() => ({}));
        if (!r.ok) {
                   if (aiResult) aiResult.textContent = `Error (${r.status}): ${data?.error || 'Unknown error'}`;
        } else {
          if (aiResult) aiResult.textContent = data?.text || '(No response)';
        }
      } catch (e) {
        if (aiResult) aiResult.textContent = `Error: ${e?.message || e || 'Unknown error'}`;
      } finally {
        if (askAiBtn) askAiBtn.disabled = false;
      }
    }
  
    if (askAiBtn) askAiBtn.addEventListener('click', handleAskAi);
    if (aiChatSelect) {
      aiChatSelect.addEventListener('change', resetAiUi);
      loadCachedChatsForAi().catch(err => console.warn('Initial AI cached chats load failed:', err?.message || err));
    }
  </script>
</body>
</html>
